<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battle Arena 2D - Multiplayer P2P</title>
    
    <!-- Firebase v10 modular SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, collection, addDoc, query, where, onSnapshot, doc, setDoc, getDoc, updateDoc, getDocs, arrayUnion, arrayRemove, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        
        // Firebase Configuration
        const firebaseConfig = {
          apiKey: "AIzaSyB6ho-GUxFGjjQprHHuxCDswIpWy9jtpcU",
          authDomain: "battlearena2dperplexity.firebaseapp.com",
          projectId: "battlearena2dperplexity",
          storageBucket: "battlearena2dperplexity.firebasestorage.app",
          messagingSenderId: "180775815859",
          appId: "1:180775815859:web:23b54f48f1e093ef0f3ec6",
          measurementId: "G-89P0EVPL9X"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Global variables - declared first
        let firebaseApp = null;
        let auth = null;
        let db = null;
        let currentUser = null;
        let game = null;
        let peer = null;
        let connection = null;
        
        // Initialize Firebase FIRST
        try {
            firebaseApp = initializeApp(firebaseConfig);
            auth = getAuth(firebaseApp);
            db = getFirestore(firebaseApp);
            
            console.log('Firebase initialized successfully');
        } catch (error) {
            console.error('Firebase initialization failed:', error);
            alert('Erro ao inicializar Firebase: ' + error.message);
        }
        
        // Make Firebase available globally
        window.firebase = { 
            auth, db, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut, 
            collection, addDoc, query, where, onSnapshot, doc, setDoc, getDoc, 
            updateDoc, getDocs, arrayUnion, arrayRemove, serverTimestamp 
        };
    </script>
    <style>
        :root {
            /* Primitive Color Tokens */
            --color-white: rgba(255, 255, 255, 1);
            --color-black: rgba(0, 0, 0, 1);
            --color-cream-50: rgba(252, 252, 249, 1);
            --color-cream-100: rgba(255, 255, 253, 1);
            --color-gray-200: rgba(245, 245, 245, 1);
            --color-gray-300: rgba(167, 169, 169, 1);
            --color-gray-400: rgba(119, 124, 124, 1);
            --color-slate-500: rgba(98, 108, 113, 1);
            --color-brown-600: rgba(94, 82, 64, 1);
            --color-charcoal-700: rgba(31, 33, 33, 1);
            --color-charcoal-800: rgba(38, 40, 40, 1);
            --color-slate-900: rgba(19, 52, 59, 1);
            --color-teal-300: rgba(50, 184, 198, 1);
            --color-teal-400: rgba(45, 166, 178, 1);
            --color-teal-500: rgba(33, 128, 141, 1);
            --color-teal-600: rgba(29, 116, 128, 1);
            --color-teal-700: rgba(26, 104, 115, 1);
            --color-teal-800: rgba(41, 150, 161, 1);
            --color-red-400: rgba(255, 84, 89, 1);
            --color-red-500: rgba(192, 21, 47, 1);
            --color-orange-400: rgba(230, 129, 97, 1);
            --color-orange-500: rgba(168, 75, 47, 1);

            /* RGB versions for opacity control */
            --color-brown-600-rgb: 94, 82, 64;
            --color-teal-500-rgb: 33, 128, 141;
            --color-slate-900-rgb: 19, 52, 59;
            --color-slate-500-rgb: 98, 108, 113;
            --color-red-500-rgb: 192, 21, 47;
            --color-red-400-rgb: 255, 84, 89;
            --color-orange-500-rgb: 168, 75, 47;
            --color-orange-400-rgb: 230, 129, 97;

            /* Semantic Color Tokens */
            --color-background: var(--color-charcoal-700);
            --color-surface: var(--color-charcoal-800);
            --color-text: var(--color-gray-200);
            --color-text-secondary: var(--color-slate-500);
            --color-primary: var(--color-teal-500);
            --color-primary-hover: var(--color-teal-600);
            --color-primary-active: var(--color-teal-700);
            --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
            --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
            --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
            --color-border: rgba(var(--color-brown-600-rgb), 0.2);
            --color-btn-primary-text: var(--color-cream-50);
            --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
            --color-error: var(--color-red-500);
            --color-success: var(--color-teal-500);
            --color-warning: var(--color-orange-500);
            --color-info: var(--color-slate-500);
            --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);

            /* Typography */
            --font-family-base: "Arial", sans-serif;
            --font-size-xs: 11px;
            --font-size-sm: 12px;
            --font-size-base: 14px;
            --font-size-lg: 16px;
            --font-size-xl: 18px;
            --font-size-2xl: 20px;
            --font-size-3xl: 24px;
            --font-size-4xl: 30px;
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-bold: 600;

            /* Spacing */
            --space-4: 4px;
            --space-8: 8px;
            --space-12: 12px;
            --space-16: 16px;
            --space-20: 20px;
            --space-24: 24px;
            --space-32: 32px;

            /* Border Radius */
            --radius-sm: 6px;
            --radius-base: 8px;
            --radius-md: 10px;
            --radius-lg: 12px;

            /* Game specific colors */
            --player-host-color: #3B82F6;
            --player-client-color: #EF4444;
            --bullet-color: #FFF;
            --arena-bg: #1a1a1a;
            --arena-wall: #4a4a4a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family-base);
            background: var(--color-background);
            color: var(--color-text);
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        canvas {
            display: block;
            background: var(--arena-bg);
            border: 2px solid var(--color-border);
        }

        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: var(--space-16);
        }

        .menu {
            background: var(--color-surface);
            padding: var(--space-32);
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-card-border);
            text-align: center;
            max-width: 400px;
            width: 100%;
        }

        .menu h1 {
            color: var(--color-primary);
            font-size: var(--font-size-4xl);
            margin-bottom: var(--space-32);
            font-weight: var(--font-weight-bold);
        }

        .menu h2 {
            font-size: var(--font-size-2xl);
            margin-bottom: var(--space-24);
        }

        .btn {
            display: block;
            width: 100%;
            padding: var(--space-16);
            margin: var(--space-8) 0;
            background: var(--color-primary);
            color: var(--color-btn-primary-text);
            border: none;
            border-radius: var(--radius-base);
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-medium);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background: var(--color-primary-hover);
        }

        .btn:active {
            background: var(--color-primary-active);
        }

        .btn-secondary {
            background: var(--color-secondary);
            color: var(--color-text);
        }

        .btn-secondary:hover {
            background: var(--color-secondary-hover);
        }

        .input {
            width: 100%;
            padding: var(--space-12);
            margin: var(--space-8) 0;
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            color: var(--color-text);
            font-size: var(--font-size-base);
        }

        .status {
            padding: var(--space-12);
            margin: var(--space-12) 0;
            border-radius: var(--radius-base);
            font-weight: var(--font-weight-medium);
        }

        .status-info {
            background: rgba(var(--color-teal-500-rgb), 0.2);
            color: var(--color-primary);
            border: 1px solid var(--color-primary);
        }

        .status-error {
            background: rgba(var(--color-red-500-rgb), 0.2);
            color: var(--color-error);
            border: 1px solid var(--color-error);
        }

        .status-success {
            background: rgba(var(--color-teal-500-rgb), 0.2);
            color: var(--color-success);
            border: 1px solid var(--color-success);
        }

        .game-container {
            position: relative;
            display: none;
        }

        .hud {
            position: absolute;
            top: var(--space-16);
            left: var(--space-16);
            right: var(--space-16);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }

        .hud-left, .hud-right {
            background: rgba(0, 0, 0, 0.8);
            padding: var(--space-12);
            border-radius: var(--radius-base);
            color: var(--color-text);
            font-weight: var(--font-weight-medium);
        }

        .health-bar {
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-sm);
            margin: var(--space-4) 0;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #fbbf24, #22c55e);
            transition: width 0.3s;
        }

        .mobile-controls {
            position: absolute;
            bottom: var(--space-20);
            left: var(--space-20);
            right: var(--space-20);
            display: none;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
            z-index: 20;
        }

        .joystick-container {
            position: relative;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }

        .joystick-base {
            width: 100%;
            height: 100%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
        }

        .joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: var(--color-primary);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }

        .shoot-btn {
            width: 80px;
            height: 80px;
            background: var(--color-error);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: var(--font-weight-bold);
            pointer-events: auto;
            cursor: pointer;
            user-select: none;
            font-size: var(--font-size-sm);
        }

        .shoot-btn:active {
            transform: scale(0.95);
            background: #dc2626;
        }

        .hidden {
            display: none !important;
        }

        .room-code {
            font-family: monospace;
            font-size: var(--font-size-2xl);
            background: rgba(var(--color-teal-500-rgb), 0.1);
            padding: var(--space-16);
            border-radius: var(--radius-base);
            border: 2px solid var(--color-primary);
            margin: var(--space-16) 0;
            letter-spacing: 2px;
        }

        .pause-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--color-surface);
            padding: var(--space-32);
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-card-border);
            z-index: 100;
            text-align: center;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
            }
        }

        /* Character Selection */
        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--space-16);
            margin: var(--space-24) 0;
        }

        .character-card {
            background: var(--color-surface);
            border: 2px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: var(--space-16);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .character-card:hover {
            border-color: var(--color-primary);
            transform: translateY(-2px);
        }

        .character-card.selected {
            border-color: var(--color-primary);
            background: rgba(var(--color-teal-500-rgb), 0.1);
        }

        .character-avatar {
            width: 60px;
            height: 60px;
            background: var(--color-primary);
            border-radius: 50%;
            margin: 0 auto var(--space-8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-size-2xl);
            font-weight: bold;
            color: white;
        }

        .character-info {
            background: var(--color-surface);
            padding: var(--space-16);
            border-radius: var(--radius-base);
            border: 1px solid var(--color-border);
            margin: var(--space-16) 0;
            min-height: 100px;
        }

        .character-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-8);
            margin-top: var(--space-8);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: var(--space-4);
            background: rgba(var(--color-brown-600-rgb), 0.1);
            border-radius: var(--radius-sm);
        }

        /* Lobby */
        .lobby-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-24);
            margin: var(--space-16) 0;
        }

        .player-list {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            max-height: 200px;
            overflow-y: auto;
        }

        .player-item {
            display: flex;
            align-items: center;
            gap: var(--space-12);
            padding: var(--space-12);
            border-bottom: 1px solid var(--color-border);
        }

        .player-item:last-child {
            border-bottom: none;
        }

        .player-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--color-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .player-info {
            flex: 1;
        }

        .player-character {
            font-size: var(--font-size-sm);
            color: var(--color-text-secondary);
        }

        .host-controls {
            margin-top: var(--space-24);
        }

        .chat-messages {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            height: 200px;
            overflow-y: auto;
            padding: var(--space-12);
            margin-bottom: var(--space-8);
        }

        .chat-message {
            margin-bottom: var(--space-8);
            padding: var(--space-8);
            background: rgba(var(--color-brown-600-rgb), 0.05);
            border-radius: var(--radius-sm);
        }

        .chat-sender {
            font-weight: bold;
            color: var(--color-primary);
        }

        .chat-input {
            display: flex;
            gap: var(--space-8);
        }

        .chat-input input {
            flex: 1;
        }

        .chat-input button {
            width: auto;
            padding: var(--space-8) var(--space-16);
        }

        /* Fullscreen Prompt */
        .fullscreen-prompt {
            position: fixed;
            top: var(--space-16);
            right: var(--space-16);
            z-index: 1000;
        }

        /* Enhanced Mobile Controls */
        .mobile-controls {
            position: absolute;
            bottom: var(--space-16);
            left: var(--space-16);
            right: var(--space-16);
            display: none;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
            z-index: 20;
        }

        .controls-left {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
        }

        .controls-right {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
            align-items: flex-end;
        }

        .special-btn {
            width: 60px;
            height: 60px;
            background: var(--color-warning);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: var(--font-weight-bold);
            pointer-events: auto;
            cursor: pointer;
            user-select: none;
            font-size: var(--font-size-xs);
        }

        .special-btn:active {
            transform: scale(0.95);
        }

        /* Map obstacles */
        .obstacle {
            position: absolute;
            background: var(--arena-wall);
        }

        /* Bullet effects */
        .bullet-trail {
            position: absolute;
            pointer-events: none;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent);
            border-radius: 2px;
        }

        /* User Info Styles */
        .user-info {
            display: flex;
            align-items: center;
            gap: var(--space-12);
            padding: var(--space-16);
            background: rgba(var(--color-brown-600-rgb), 0.1);
            border-radius: var(--radius-base);
            margin-bottom: var(--space-24);
            border: 1px solid var(--color-border);
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid var(--color-primary);
        }

        .user-email {
            font-size: var(--font-size-sm);
            color: var(--color-text-secondary);
        }

        .btn-icon {
            background: var(--color-secondary);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            padding: var(--space-8);
            cursor: pointer;
            color: var(--color-text);
            font-size: var(--font-size-lg);
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: var(--color-secondary-hover);
        }

        /* Friends Panel */
        .friends-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: var(--color-surface);
            border-left: 1px solid var(--color-border);
            z-index: 1000;
            transition: right 0.3s ease;
            box-shadow: var(--shadow-lg);
        }

        .friends-panel.show {
            right: 0;
        }

        .friends-content {
            padding: var(--space-24);
            height: 100%;
            overflow-y: auto;
        }

        .friends-tabs {
            display: flex;
            margin-bottom: var(--space-16);
            border-bottom: 1px solid var(--color-border);
        }

        .tab-btn {
            flex: 1;
            padding: var(--space-12);
            background: none;
            border: none;
            color: var(--color-text-secondary);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab-btn.active {
            color: var(--color-primary);
            border-bottom-color: var(--color-primary);
        }

        .tab-content {
            margin-top: var(--space-16);
        }

        .friends-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
        }

        .friend-item {
            display: flex;
            align-items: center;
            gap: var(--space-12);
            padding: var(--space-12);
            background: rgba(var(--color-brown-600-rgb), 0.05);
            border-radius: var(--radius-base);
            border: 1px solid var(--color-border);
        }

        .friend-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid var(--color-border);
        }

        .friend-info {
            flex: 1;
        }

        .friend-name {
            font-weight: var(--font-weight-medium);
        }

        .friend-status {
            font-size: var(--font-size-sm);
            color: var(--color-text-secondary);
        }

        .friend-status.online {
            color: var(--color-success);
        }

        .friend-actions {
            display: flex;
            gap: var(--space-4);
        }

        .btn-small {
            padding: var(--space-4) var(--space-8);
            font-size: var(--font-size-sm);
            border-radius: var(--radius-sm);
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary-small {
            background: var(--color-primary);
            color: var(--color-btn-primary-text);
        }

        .btn-secondary-small {
            background: var(--color-secondary);
            color: var(--color-text);
        }

        .friend-requests {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
        }

        .friend-request {
            padding: var(--space-16);
            background: var(--color-secondary);
            border-radius: var(--radius-base);
            border: 1px solid var(--color-border);
        }

        .request-actions {
            display: flex;
            gap: var(--space-8);
            margin-top: var(--space-12);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .lobby-content {
                grid-template-columns: 1fr;
            }
            
            .character-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .menu {
                max-width: 90vw !important;
            }
            
            .friends-panel {
                width: 100vw;
                right: -100vw;
            }
            
            .user-info {
                flex-direction: column;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen" class="container">
        <div class="menu">
            <h1>‚öîÔ∏è Battle Arena 2D</h1>
            <p>Fa√ßa login para jogar e conectar com amigos</p>
            <button class="btn" onclick="window.game && window.game.signInWithGoogle()">üîê Login com Google</button>
            <div id="loginStatus" class="status status-info hidden">Conectando...</div>
        </div>
    </div>

    <div id="mainMenu" class="container hidden">
        <div class="menu">
            <h1>‚öîÔ∏è Battle Arena 2D</h1>
            <div id="userInfo" class="user-info">
                <img id="userAvatar" class="user-avatar" src="" alt="Avatar">
                <div>
                    <div id="userName">Nome do Usu√°rio</div>
                    <div id="userEmail" class="user-email">email@example.com</div>
                </div>
                <button class="btn-icon" onclick="window.game && window.game.showFriendsPanel()" title="Amigos">üë•</button>
                <button class="btn-icon" onclick="window.game && window.game.signOut()" title="Logout">üö™</button>
            </div>
            <button class="btn" onclick="window.game && window.game.showHostMenu()">üéØ Host Game</button>
            <button class="btn" onclick="window.game && window.game.showJoinMenu()">üîó Join Game</button>
            <button class="btn btn-secondary" onclick="window.game && window.game.showSettings()">‚öôÔ∏è Settings</button>
            <button class="btn btn-secondary" onclick="window.game && window.game.showInstructions()">‚ùì How to Play</button>
        </div>
    </div>

    <div id="hostMenu" class="container hidden">
        <div class="menu">
            <h2>Host Game</h2>
            <div id="hostStatus" class="status status-info">Initializing...</div>
            <div id="roomCodeContainer" class="hidden">
                <div class="room-code" id="roomCodeDisplay"></div>
                <button class="btn btn-secondary" onclick="window.game && window.game.copyRoomCode()">üìã Copy Code</button>
            </div>
            <div id="waitingMessage" class="hidden">
                <p>Share this code with your friends!</p>
                <p>Waiting for players to join...</p>
            </div>
            <button class="btn btn-secondary" onclick="window.game && window.game.showMainMenu()">‚Üê Back</button>
        </div>
    </div>

    <div id="joinMenu" class="container hidden">
        <div class="menu">
            <h2>Join Game</h2>
            <input type="text" id="roomCodeInput" class="input" placeholder="Enter room code or paste here" maxlength="10">
            <button class="btn" onclick="window.game && window.game.pasteRoomCode()">üìã Paste Code</button>
            <button class="btn" onclick="window.game && window.game.joinRoom()">Connect</button>
            <div id="joinStatus" class="status status-info hidden">Connecting...</div>
            <button class="btn btn-secondary" onclick="window.game && window.game.showMainMenu()">‚Üê Back</button>
        </div>
    </div>

    <div id="settingsMenu" class="container hidden">
        <div class="menu">
            <h2>Settings</h2>
            <label>Player Name:</label>
            <input type="text" id="playerName" class="input" placeholder="Enter your name" maxlength="20">
            <label>Sound Effects:</label>
            <select id="soundToggle" class="input">
                <option value="true">On</option>
                <option value="false">Off</option>
            </select>
            <button class="btn" onclick="window.game && window.game.saveSettings()">Save Settings</button>
            <button class="btn btn-secondary" onclick="window.game && window.game.showMainMenu()">‚Üê Back</button>
        </div>
    </div>

    <div id="instructionsMenu" class="container hidden">
        <div class="menu">
            <h2>How to Play</h2>
            <div style="text-align: left; line-height: 1.6;">
                <p><strong>Desktop Controls:</strong></p>
                <p>‚Ä¢ WASD - Move</p>
                <p>‚Ä¢ Mouse - Aim &amp; Shoot</p>
                <p>‚Ä¢ ESC - Pause</p>
                <br>
                <p><strong>Mobile Controls:</strong></p>
                <p>‚Ä¢ Left joystick - Move</p>
                <p>‚Ä¢ Right button - Shoot</p>
                <br>
                <p><strong>Objective:</strong></p>
                <p>‚Ä¢ Shoot your opponent</p>
                <p>‚Ä¢ First to 10 kills wins!</p>
                <p>‚Ä¢ Respawn after 3 seconds</p>
            </div>
            <button class="btn" onclick="window.game && window.game.showMainMenu()">‚Üê Back</button>
        </div>
    </div>

    <div id="gameContainer" class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="hud">
            <div class="hud-left">
                <div>Health: <span id="healthText">100</span>/100</div>
                <div class="health-bar">
                    <div class="health-fill" id="healthBar" style="width: 100%"></div>
                </div>
                <div>Score: <span id="scoreText">0</span></div>
                <div>Ping: <span id="pingText">--</span>ms</div>
            </div>
            <div class="hud-right">
                <div id="opponentInfo">Opponent: --</div>
                <div>Opponent Score: <span id="opponentScore">0</span></div>
                <button class="btn" style="pointer-events: auto; margin-top: 10px;" onclick="game.pauseGame()">‚è∏Ô∏è Pause</button>
            </div>
        </div>

        <div class="mobile-controls">
            <div class="controls-left">
                <div class="joystick-container" id="joystickContainer">
                    <div class="joystick-base"></div>
                    <div class="joystick-knob" id="joystickKnob"></div>
                </div>
            </div>
            <div class="controls-right">
                <div class="shoot-btn" id="shootBtn">üî´<br>FIRE</div>
                <div class="special-btn" id="specialBtn">‚ú®<br>SPEC</div>
            </div>
        </div>

        <div id="pauseMenu" class="pause-menu hidden">
            <h2>Game Paused</h2>
            <button class="btn" onclick="window.game && window.game.resumeGame()">‚ñ∂Ô∏è Resume</button>
            <button class="btn btn-secondary" onclick="window.game && window.game.showMainMenu()">üè† Main Menu</button>
        </div>
    </div>

    <!-- Character Selection -->
    <div id="characterSelection" class="container hidden">
        <div class="menu" style="max-width: 600px;">
            <h2>Choose Your Fighter</h2>
            <div id="characterGrid" class="character-grid"></div>
            <div id="characterInfo" class="character-info"></div>
            <button class="btn" id="confirmCharacterBtn" onclick="window.game && window.game.confirmCharacter()" disabled>Confirm Selection</button>
            <button class="btn btn-secondary" onclick="window.game && window.game.showMainMenu()">‚Üê Back</button>
        </div>
    </div>

    <!-- Lobby -->
    <div id="lobbyMenu" class="container hidden">
        <div class="menu" style="max-width: 800px;">
            <h2>Game Lobby</h2>
            <div class="lobby-content">
                <div class="lobby-left">
                    <h3>Players (<span id="playerCount">1</span>/8)</h3>
                    <div id="playerList" class="player-list"></div>
                    
                    <div id="hostControls" class="host-controls hidden">
                        <h3>Game Settings</h3>
                        <select id="gameModeSelect" class="input">
                            <option value="deathmatch">Todos vs Todos</option>
                            <option value="team_vs_team">Equipe vs Equipe</option>
                            <option value="bots">Todos vs Bots</option>
                            <option value="zombies">Ordas de Zumbis</option>
                        </select>
                        <button class="btn" onclick="window.game && window.game.startMatchFromLobby()">üöÄ Start Game</button>
                    </div>
                </div>
                
                <div class="lobby-right">
                    <h3>Chat</h3>
                    <div id="chatMessages" class="chat-messages"></div>
                    <div class="chat-input">
                        <input type="text" id="chatInput" class="input" placeholder="Type a message..." maxlength="100">
                        <button class="btn" onclick="window.game && window.game.sendChatMessage()">Send</button>
                    </div>
                </div>
            </div>
            <button class="btn btn-secondary" onclick="game.showMainMenu()">‚Üê Leave Lobby</button>
        </div>
    </div>

    <!-- Friends Panel -->
    <div id="friendsPanel" class="friends-panel hidden">
        <div class="friends-content">
            <h3>Amigos</h3>
            <div class="friends-tabs">
                <button class="tab-btn active" onclick="window.game && window.game.showFriendsTab('list')">Lista</button>
                <button class="tab-btn" onclick="window.game && window.game.showFriendsTab('requests')">Pedidos</button>
                <button class="tab-btn" onclick="window.game && window.game.showFriendsTab('add')">Adicionar</button>
            </div>
            
            <div id="friendsListTab" class="tab-content">
                <div id="friendsList" class="friends-list"></div>
            </div>
            
            <div id="friendsRequestsTab" class="tab-content hidden">
                <div id="friendRequests" class="friend-requests"></div>
            </div>
            
            <div id="addFriendTab" class="tab-content hidden">
                <input type="email" id="friendEmail" class="input" placeholder="Email do amigo">
                <button class="btn" onclick="window.game && window.game.sendFriendRequest()">Enviar Pedido</button>
                <div id="addFriendStatus" class="status hidden"></div>
            </div>
            
            <button class="btn btn-secondary" onclick="window.game && window.game.closeFriendsPanel()">Fechar</button>
        </div>
    </div>

    <!-- Fullscreen prompt for mobile -->
    <div id="fullscreenPrompt" class="fullscreen-prompt hidden">
        <button class="btn" onclick="window.game && window.game.requestFullscreen()">üì± Enter Fullscreen</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverMenu" class="container hidden">
        <div class="menu">
            <h2 id="gameOverTitle">Game Over!</h2>
            <div id="gameOverStats"></div>
            <button class="btn" onclick="window.game && window.game.returnToLobby()">üè† Return to Lobby</button>
            <button class="btn btn-secondary" onclick="window.game && window.game.showMainMenu()">Main Menu</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        // Game data - 10 Unique Characters
        const CHARACTERS = {
            archer: {
                id: 'archer',
                name: 'Archer',
                avatar: 'üèπ',
                health: 90,
                speed: 140,
                attack: {
                    type: 'long_range',
                    damage: 45,
                    fire_rate: 800,
                    bullet_count: 1,
                    range: 500
                },
                special: {
                    type: 'piercing_arrow',
                    effect: 'flecha que atravessa m√∫ltiplos inimigos',
                    cooldown: 8000
                }
            },
            warrior: {
                id: 'warrior',
                name: 'Warrior', 
                avatar: '‚öîÔ∏è',
                health: 160,
                speed: 110,
                attack: {
                    type: 'melee',
                    damage: 65,
                    fire_rate: 600,
                    bullet_count: 1,
                    range: 80
                },
                special: {
                    type: 'spin_attack',
                    effect: 'ataque girat√≥rio que atinge √°rea ao redor',
                    cooldown: 10000
                }
            },
            mage: {
                id: 'mage',
                name: 'Mage',
                avatar: 'üîÆ',
                health: 75,
                speed: 125,
                attack: {
                    type: 'fireball',
                    damage: 40,
                    fire_rate: 400,
                    bullet_count: 3,
                    range: 300
                },
                special: {
                    type: 'meteor',
                    effect: 'meteoro que causa dano em √°rea',
                    cooldown: 12000
                }
            },
            assassin: {
                id: 'assassin',
                name: 'Assassin',
                avatar: 'üó°Ô∏è',
                health: 80,
                speed: 180,
                attack: {
                    type: 'dual_blades',
                    damage: 35,
                    fire_rate: 200,
                    bullet_count: 2,
                    range: 120
                },
                special: {
                    type: 'stealth_dash',
                    effect: 'teleporte invis√≠vel com dano cr√≠tico',
                    cooldown: 8000
                }
            },
            tank: {
                id: 'tank',
                name: 'Tank',
                avatar: 'üõ°Ô∏è',
                health: 200,
                speed: 100,
                attack: {
                    type: 'cannon',
                    damage: 70,
                    fire_rate: 1200,
                    bullet_count: 1,
                    range: 350
                },
                special: {
                    type: 'shield_slam',
                    effect: 'escudo que reflete proj√©teis',
                    cooldown: 15000
                }
            },
            sniper: {
                id: 'sniper',
                name: 'Sniper',
                avatar: 'üéØ',
                health: 70,
                speed: 120,
                attack: {
                    type: 'precision',
                    damage: 80,
                    fire_rate: 1000,
                    bullet_count: 1,
                    range: 500
                },
                special: {
                    type: 'headshot',
                    effect: 'tiro com dano massivo e precis√£o perfeita',
                    cooldown: 6000
                }
            },
            pyro: {
                id: 'pyro',
                name: 'Pyro',
                avatar: 'üî•',
                health: 110,
                speed: 130,
                attack: {
                    type: 'flamethrower',
                    damage: 25,
                    fire_rate: 100,
                    bullet_count: 5,
                    range: 200
                },
                special: {
                    type: 'fire_wall',
                    effect: 'muro de fogo que causa dano cont√≠nuo',
                    cooldown: 10000
                }
            },
            engineer: {
                id: 'engineer',
                name: 'Engineer',
                avatar: 'üîß',
                health: 95,
                speed: 115,
                attack: {
                    type: 'grenade',
                    damage: 50,
                    fire_rate: 700,
                    bullet_count: 1,
                    range: 280
                },
                special: {
                    type: 'turret',
                    effect: 'constr√≥i torre que atira automaticamente',
                    cooldown: 20000
                }
            },
            healer: {
                id: 'healer',
                name: 'Healer',
                avatar: 'üíö',
                health: 85,
                speed: 135,
                attack: {
                    type: 'heal_beam',
                    damage: 20,
                    fire_rate: 300,
                    bullet_count: 1,
                    range: 250
                },
                special: {
                    type: 'mass_heal',
                    effect: 'cura todos os aliados pr√≥ximos',
                    cooldown: 12000
                }
            },
            berserker: {
                id: 'berserker',
                name: 'Berserker',
                avatar: 'ü™ì',
                health: 140,
                speed: 160,
                attack: {
                    type: 'rage_axe',
                    damage: 55,
                    fire_rate: 450,
                    bullet_count: 1,
                    range: 100
                },
                special: {
                    type: 'blood_rage',
                    effect: 'aumenta velocidade e dano drasticamente',
                    cooldown: 8000
                }
            }
        };

        const MAPS = {
            desert: {
                id: 'desert',
                name: 'Deserto Fragmentado',
                width: 1400,
                height: 900,
                obstacles: [
                    { type: 'wall', x: 300, y: 300, w: 200, h: 20 },
                    { type: 'destructible', x: 700, y: 500, w: 100, h: 30 },
                    { type: 'cover', x: 900, y: 200, w: 70, h: 70 },
                    { type: 'wall', x: 1000, y: 800, w: 130, h: 40 },
                    { type: 'wall', x: 100, y: 100, w: 150, h: 25 },
                    { type: 'cover', x: 500, y: 150, w: 80, h: 80 },
                    { type: 'destructible', x: 200, y: 600, w: 120, h: 40 }
                ]
            }
        };

        const GAME_MODES = {
            deathmatch: {
                id: 'deathmatch',
                name: 'Todos vs Todos',
                description: 'Cada jogador por si, vence quem atingir 10 elimina√ß√µes.',
                min_players: 2,
                max_players: 8,
                win_condition: 'kills',
                win_target: 10,
                respawn: true
            },
            team_vs_team: {
                id: 'team_vs_team',
                name: 'Equipe vs Equipe',
                description: 'Times balanceados, primeira equipe a 15 elimina√ß√µes vence.',
                min_players: 2,
                max_players: 8,
                win_condition: 'team_kills',
                win_target: 15,
                respawn: true,
                auto_balance: true
            },
            bots: {
                id: 'bots',
                name: 'Todos vs Bots',
                description: 'Cooperativo contra IA inteligente. Sobreviva 5 minutos.',
                min_players: 1,
                max_players: 6,
                win_condition: 'survive_time',
                win_target: 300000, // 5 minutes
                bot_count: 8,
                bot_difficulty: 'medium',
                respawn: true
            },
            zombies: {
                id: 'zombies',
                name: 'Ordas de Zumbis',
                description: 'Sobreviva a ondas infinitas. Cada onda fica mais dif√≠cil.',
                min_players: 1,
                max_players: 6,
                win_condition: 'waves',
                wave_duration: 60000, // 1 minute per wave
                zombies_per_wave: 5,
                wave_multiplier: 1.5,
                respawn: false // Permadeath mode
            }
        };

        class BattleArena2D {
            constructor() {
                // Wait for DOM to be fully loaded
                if (!document.getElementById('gameCanvas')) {
                    throw new Error('Canvas element not found');
                }
                
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.isHost = false;
                this.peer = null;
                this.connection = null;
                this.connections = new Map(); // For multiple connections
                this.gameState = 'menu';
                this.roomCode = '';
                this.playerName = 'Player';
                this.soundEnabled = true;
                
                // Game state
                this.selectedCharacter = null;
                this.gameMode = 'deathmatch';
                this.currentMap = MAPS.desert;
                this.players = new Map();
                this.chatMessages = [];
                
                // User data
                this.currentUser = null;
                this.friends = new Map();
                this.friendRequests = [];
                this.onlineFriends = new Set();
                
                // Camera
                this.camera = { x: 0, y: 0 };
                this.cameraTarget = { x: 0, y: 0 };
                
                // Game objects
                this.localPlayer = {
                    id: 'local',
                    x: 100,
                    y: 100,
                    angle: 0,
                    health: 100,
                    maxHealth: 100,
                    score: 0,
                    isAlive: true,
                    lastShot: 0,
                    lastSpecial: 0,
                    name: 'You',
                    character: null,
                    team: 1
                };
                
                this.remotePlayers = new Map();
                this.bullets = [];
                this.particles = [];
                this.obstacles = [];
                this.bots = [];
                this.zombies = [];
                
                // Controls
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };
                this.joystick = { active: false, x: 0, y: 0, centerX: 0, centerY: 0 };
                this.isMobile = this.detectMobile();
                
                // Game settings
                this.PLAYER_SIZE = 15;
                this.BULLET_SPEED = 400;
                this.RESPAWN_TIME = 3000;
                this.WIN_SCORE = 10;
                this.SPECIAL_COOLDOWN = 5000;
                
                // Visual settings
                this.CAMERA_SMOOTHING = 0.1;
                this.TRAIL_LENGTH = 10;
                this.PARTICLE_COUNT = 20;
                
                // Game mode specific
                this.gameTimer = 0;
                this.waveNumber = 1;
                this.zombiesKilled = 0;
                this.teamScores = { team1: 0, team2: 0 };
                this.turrets = [];
                this.fireWalls = [];
                
                // Bot AI system
                this.botUpdateInterval = 100;
                this.lastBotUpdate = 0;
                
                // Network
                this.lastNetworkUpdate = 0;
                this.networkUpdateRate = 1000 / 20; // 20 updates per second
                this.ping = 0;
                this.lastPingTime = 0;
                
                this.init();
                this.checkFullscreenMobile();
                // Firebase will be initialized from DOMContentLoaded
            }
            
            // Firebase Authentication & Friends System
            async initFirebase() {
                try {
                    // Firebase should already be initialized
                    if (!window.firebase || !window.firebase.auth) {
                        throw new Error('Firebase not properly initialized');
                    }
                    
                    const { auth, onAuthStateChanged } = window.firebase;
                    
                    // Setup auth state listener
                    onAuthStateChanged(auth, async (user) => {
                        try {
                            if (user) {
                                this.currentUser = user;
                                console.log('User logged in:', user.email);
                                await this.loadUserData();
                                await this.setupFriendsListener();
                                this.showMainMenu();
                            } else {
                                this.currentUser = null;
                                console.log('User logged out');
                                this.showLoginScreen();
                            }
                        } catch (error) {
                            console.error('Error in auth state change:', error);
                        }
                    });
                    
                } catch (error) {
                    console.error('Firebase initialization error:', error);
                    document.getElementById('loginScreen').innerHTML = `
                        <div class="menu">
                            <h1>‚öîÔ∏è Battle Arena 2D</h1>
                            <div class="status status-error">Erro de inicializa√ß√£o: ${error.message}</div>
                            <button class="btn" onclick="window.location.reload()">üîÑ Recarregar P√°gina</button>
                        </div>
                    `;
                }
            }
            
            showLoginScreen() {
                this.hideAllMenus();
                document.getElementById('loginScreen').classList.remove('hidden');
            }
            
            async signInWithGoogle() {
                try {
                    const statusElement = document.getElementById('loginStatus');
                    statusElement.classList.remove('hidden');
                    statusElement.textContent = 'Conectando...';
                    statusElement.className = 'status status-info';
                    
                    const { auth, GoogleAuthProvider, signInWithPopup } = window.firebase;
                    
                    if (!auth || !GoogleAuthProvider || !signInWithPopup) {
                        throw new Error('Firebase auth services not available');
                    }
                    
                    const provider = new GoogleAuthProvider();
                    provider.addScope('email');
                    provider.addScope('profile');
                    
                    console.log('Attempting Google sign-in...');
                    const result = await signInWithPopup(auth, provider);
                    
                    this.currentUser = result.user;
                    console.log('Sign-in successful for:', result.user.email);
                    
                    await this.createUserProfile();
                    
                    statusElement.textContent = 'Login realizado com sucesso!';
                    statusElement.className = 'status status-success';
                    
                } catch (error) {
                    console.error('Login failed:', error);
                    const statusElement = document.getElementById('loginStatus');
                    
                    let errorMessage = 'Erro desconhecido';
                    if (error.code === 'auth/popup-closed-by-user') {
                        errorMessage = 'Login cancelado pelo usu√°rio';
                    } else if (error.code === 'auth/popup-blocked') {
                        errorMessage = 'Popup bloqueado pelo navegador';
                    } else if (error.code === 'auth/network-request-failed') {
                        errorMessage = 'Erro de conex√£o';
                    } else {
                        errorMessage = error.message;
                    }
                    
                    statusElement.textContent = 'Erro no login: ' + errorMessage;
                    statusElement.className = 'status status-error';
                }
            }
            
            async signOut() {
                try {
                    console.log('Signing out user...');
                    const { auth, signOut } = window.firebase;
                    
                    // Update user status to offline
                    if (this.currentUser && window.firebase.db) {
                        const { db, doc, updateDoc, serverTimestamp } = window.firebase;
                        try {
                            await updateDoc(doc(db, 'users', this.currentUser.uid), {
                                isOnline: false,
                                lastOnline: serverTimestamp()
                            });
                        } catch (error) {
                            console.warn('Could not update user offline status:', error);
                        }
                    }
                    
                    await signOut(auth);
                    console.log('User signed out successfully');
                    
                } catch (error) {
                    console.error('Sign out error:', error);
                    // Force redirect to login even if signout fails
                    this.currentUser = null;
                    this.showLoginScreen();
                }
            }
            
            async createUserProfile() {
                if (!this.currentUser) {
                    console.log('No current user for profile creation');
                    return;
                }
                
                try {
                    console.log('Creating/updating user profile...');
                    const { db, doc, setDoc, getDoc, updateDoc, serverTimestamp } = window.firebase;
                    
                    const userRef = doc(db, 'users', this.currentUser.uid);
                    const userSnap = await getDoc(userRef);
                    
                    if (!userSnap.exists()) {
                        console.log('Creating new user profile');
                        await setDoc(userRef, {
                            uid: this.currentUser.uid,
                            name: this.currentUser.displayName || 'Usu√°rio An√¥nimo',
                            email: this.currentUser.email,
                            photoURL: this.currentUser.photoURL || '',
                            createdAt: serverTimestamp(),
                            lastOnline: serverTimestamp(),
                            isOnline: true,
                            friends: [],
                            stats: {
                                gamesPlayed: 0,
                                wins: 0,
                                kills: 0,
                                deaths: 0
                            }
                        });
                    } else {
                        console.log('Updating existing user profile');
                        await updateDoc(userRef, {
                            lastOnline: serverTimestamp(),
                            isOnline: true,
                            name: this.currentUser.displayName || userSnap.data().name,
                            photoURL: this.currentUser.photoURL || userSnap.data().photoURL
                        });
                    }
                    
                    console.log('User profile created/updated successfully');
                } catch (error) {
                    console.error('Error creating user profile:', error);
                    throw error;
                }
            }
            
            async loadUserData() {
                if (!this.currentUser) {
                    console.log('No current user to load data for');
                    return;
                }
                
                try {
                    console.log('Loading user data for:', this.currentUser.email);
                    
                    // Update UI with user info
                    const userName = document.getElementById('userName');
                    const userEmail = document.getElementById('userEmail');
                    const userAvatar = document.getElementById('userAvatar');
                    
                    if (userName) userName.textContent = this.currentUser.displayName || 'Usu√°rio';
                    if (userEmail) userEmail.textContent = this.currentUser.email || '';
                    if (userAvatar) {
                        userAvatar.src = this.currentUser.photoURL || '/api/placeholder/40/40';
                        userAvatar.onerror = () => {
                            userAvatar.src = '/api/placeholder/40/40';
                        };
                    }
                    
                    this.playerName = this.currentUser.displayName || 'Jogador';
                    this.localPlayer.name = this.playerName;
                    
                    // Update online status
                    const { db, doc, updateDoc, serverTimestamp } = window.firebase;
                    await updateDoc(doc(db, 'users', this.currentUser.uid), {
                        lastOnline: serverTimestamp(),
                        isOnline: true
                    });
                    
                    console.log('User data loaded successfully');
                } catch (error) {
                    console.error('Error loading user data:', error);
                    // Continue anyway, don't block the UI
                }
            }
            
            async setupFriendsListener() {
                if (!this.currentUser) {
                    console.log('No current user for friends listener');
                    return;
                }
                
                try {
                    console.log('Setting up friends listener...');
                    const { db, collection, query, where, onSnapshot } = window.firebase;
                    
                    // Listen for friend requests
                    const requestsQuery = query(
                        collection(db, 'friendRequests'),
                        where('toUserId', '==', this.currentUser.uid),
                        where('status', '==', 'pending')
                    );
                    
                    onSnapshot(requestsQuery, (snapshot) => {
                        this.friendRequests = [];
                        snapshot.forEach(doc => {
                            this.friendRequests.push({ id: doc.id, ...doc.data() });
                        });
                        this.updateFriendsUI();
                    }, (error) => {
                        console.error('Error in friend requests listener:', error);
                    });
                    
                    // Listen for friends list changes
                    await this.loadFriends();
                    
                    console.log('Friends listener setup complete');
                } catch (error) {
                    console.error('Error setting up friends listener:', error);
                }
            }
            
            async loadFriends() {
                if (!this.currentUser) return;
                
                const { db, doc, getDoc } = window.firebase;
                const userDoc = await getDoc(doc(db, 'users', this.currentUser.uid));
                
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    const friendIds = userData.friends || [];
                    
                    // Load friend details
                    this.friends.clear();
                    for (const friendId of friendIds) {
                        const friendDoc = await getDoc(doc(db, 'users', friendId));
                        if (friendDoc.exists()) {
                            this.friends.set(friendId, friendDoc.data());
                        }
                    }
                    
                    this.updateFriendsUI();
                }
            }
            
            async sendFriendRequest() {
                const email = document.getElementById('friendEmail').value.trim();
                if (!email) return;
                
                const status = document.getElementById('addFriendStatus');
                status.classList.remove('hidden');
                status.textContent = 'Enviando pedido...';
                status.className = 'status status-info';
                
                try {
                    const { db, collection, query, where, getDocs, addDoc, serverTimestamp } = window.firebase;
                    
                    // Find user by email
                    const usersQuery = query(collection(db, 'users'), where('email', '==', email));
                    const usersSnap = await getDocs(usersQuery);
                    
                    if (usersSnap.empty) {
                        status.textContent = 'Usu√°rio n√£o encontrado';
                        status.className = 'status status-error';
                        return;
                    }
                    
                    const targetUser = usersSnap.docs[0];
                    const targetUserId = targetUser.id;
                    
                    if (targetUserId === this.currentUser.uid) {
                        status.textContent = 'Voc√™ n√£o pode adicionar a si mesmo';
                        status.className = 'status status-error';
                        return;
                    }
                    
                    // Check if already friends
                    if (this.friends.has(targetUserId)) {
                        status.textContent = 'Voc√™s j√° s√£o amigos';
                        status.className = 'status status-error';
                        return;
                    }
                    
                    // Check if request already exists
                    const requestsQuery = query(
                        collection(db, 'friendRequests'),
                        where('fromUserId', '==', this.currentUser.uid),
                        where('toUserId', '==', targetUserId),
                        where('status', '==', 'pending')
                    );
                    const existingRequests = await getDocs(requestsQuery);
                    
                    if (!existingRequests.empty) {
                        status.textContent = 'Pedido j√° enviado';
                        status.className = 'status status-warning';
                        return;
                    }
                    
                    // Send friend request
                    await addDoc(collection(db, 'friendRequests'), {
                        fromUserId: this.currentUser.uid,
                        fromUserName: this.currentUser.displayName,
                        fromUserEmail: this.currentUser.email,
                        fromUserPhoto: this.currentUser.photoURL,
                        toUserId: targetUserId,
                        toUserName: targetUser.data().name,
                        toUserEmail: targetUser.data().email,
                        status: 'pending',
                        createdAt: serverTimestamp()
                    });
                    
                    status.textContent = 'Pedido enviado com sucesso!';
                    status.className = 'status status-success';
                    document.getElementById('friendEmail').value = '';
                    
                } catch (error) {
                    console.error('Error sending friend request:', error);
                    status.textContent = 'Erro ao enviar pedido';
                    status.className = 'status status-error';
                }
            }
            
            async acceptFriendRequest(requestId, fromUserId) {
                try {
                    const { db, doc, updateDoc, arrayUnion } = window.firebase;
                    
                    // Update request status
                    await updateDoc(doc(db, 'friendRequests', requestId), {
                        status: 'accepted'
                    });
                    
                    // Add to both users' friends lists
                    await updateDoc(doc(db, 'users', this.currentUser.uid), {
                        friends: arrayUnion(fromUserId)
                    });
                    
                    await updateDoc(doc(db, 'users', fromUserId), {
                        friends: arrayUnion(this.currentUser.uid)
                    });
                    
                    this.loadFriends();
                } catch (error) {
                    console.error('Error accepting friend request:', error);
                }
            }
            
            async rejectFriendRequest(requestId) {
                try {
                    const { db, doc, updateDoc } = window.firebase;
                    await updateDoc(doc(db, 'friendRequests', requestId), {
                        status: 'rejected'
                    });
                } catch (error) {
                    console.error('Error rejecting friend request:', error);
                }
            }
            
            showFriendsPanel() {
                document.getElementById('friendsPanel').classList.add('show');
                this.updateFriendsUI();
            }
            
            closeFriendsPanel() {
                document.getElementById('friendsPanel').classList.remove('show');
            }
            
            showFriendsTab(tabName) {
                // Update tab buttons
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                if (event && event.target) {
                    event.target.classList.add('active');
                }
                
                // Show/hide tab content
                document.getElementById('friendsListTab').classList.toggle('hidden', tabName !== 'list');
                document.getElementById('friendsRequestsTab').classList.toggle('hidden', tabName !== 'requests');
                document.getElementById('addFriendTab').classList.toggle('hidden', tabName !== 'add');
            }
            
            updateFriendsUI() {
                this.updateFriendsList();
                this.updateFriendRequests();
            }
            
            updateFriendsList() {
                const friendsList = document.getElementById('friendsList');
                friendsList.innerHTML = '';
                
                if (this.friends.size === 0) {
                    friendsList.innerHTML = '<p style="text-align: center; color: var(--color-text-secondary);">Nenhum amigo ainda</p>';
                    return;
                }
                
                this.friends.forEach((friend, friendId) => {
                    const isOnline = this.onlineFriends.has(friendId);
                    const friendItem = document.createElement('div');
                    friendItem.className = 'friend-item';
                    friendItem.innerHTML = `
                        <img src="${friend.photoURL || '/api/placeholder/32/32'}" class="friend-avatar" alt="Avatar">
                        <div class="friend-info">
                            <div class="friend-name">${friend.name}</div>
                            <div class="friend-status ${isOnline ? 'online' : ''}">
                                ${isOnline ? '‚Ä¢ Online' : '‚Ä¢ Offline'}
                            </div>
                        </div>
                        <div class="friend-actions">
                            ${isOnline ? `<button class="btn-small btn-primary-small" onclick="window.game && window.game.inviteFriend('${friendId}')">Convidar</button>` : ''}
                            <button class="btn-small btn-secondary-small" onclick="window.game && window.game.removeFriend('${friendId}')">Remover</button>
                        </div>
                    `;
                    friendsList.appendChild(friendItem);
                });
            }
            
            updateFriendRequests() {
                const requestsList = document.getElementById('friendRequests');
                requestsList.innerHTML = '';
                
                if (this.friendRequests.length === 0) {
                    requestsList.innerHTML = '<p style="text-align: center; color: var(--color-text-secondary);">Nenhum pedido pendente</p>';
                    return;
                }
                
                this.friendRequests.forEach(request => {
                    const requestItem = document.createElement('div');
                    requestItem.className = 'friend-request';
                    requestItem.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                            <img src="${request.fromUserPhoto || '/api/placeholder/32/32'}" class="friend-avatar" alt="Avatar">
                            <div>
                                <div class="friend-name">${request.fromUserName}</div>
                                <div class="friend-status">${request.fromUserEmail}</div>
                            </div>
                        </div>
                        <p style="margin: 8px 0; font-size: 14px;">Quer ser seu amigo</p>
                        <div class="request-actions">
                            <button class="btn-small btn-primary-small" onclick="window.game && window.game.acceptFriendRequest('${request.id}', '${request.fromUserId}')">Aceitar</button>
                            <button class="btn-small btn-secondary-small" onclick="window.game && window.game.rejectFriendRequest('${request.id}')">Recusar</button>
                        </div>
                    `;
                    requestsList.appendChild(requestItem);
                });
            }
            
            async inviteFriend(friendId) {
                // TODO: Implement friend invitation to current lobby/room
                alert('Convite enviado! (Funcionalidade em desenvolvimento)');
            }
            
            async removeFriend(friendId) {
                if (!confirm('Tem certeza que deseja remover este amigo?')) return;
                
                try {
                    const { db, doc, updateDoc, arrayRemove } = window.firebase;
                    
                    // Remove from both users' friends lists
                    await updateDoc(doc(db, 'users', this.currentUser.uid), {
                        friends: arrayRemove(friendId)
                    });
                    
                    await updateDoc(doc(db, 'users', friendId), {
                        friends: arrayRemove(this.currentUser.uid)
                    });
                    
                    this.loadFriends();
                } catch (error) {
                    console.error('Error removing friend:', error);
                }
            }
            
            detectMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
            
            checkFullscreenMobile() {
                if (this.isMobile) {
                    setInterval(() => {
                        if (!document.fullscreenElement && this.gameState !== 'menu') {
                            document.getElementById('fullscreenPrompt').classList.remove('hidden');
                        } else {
                            document.getElementById('fullscreenPrompt').classList.add('hidden');
                        }
                    }, 2000);
                }
            }
            
            requestFullscreen() {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                }
                document.getElementById('fullscreenPrompt').classList.add('hidden');
            }
            
            init() {
                try {
                    console.log('Initializing game components...');
                    this.loadSettings();
                    this.setupEventListeners();
                    this.setupMobileControls();
                    this.gameLoop();
                    console.log('Game initialized successfully');
                } catch (error) {
                    console.error('Game initialization error:', error);
                    throw error;
                }
            }
            
            loadSettings() {
                // Settings stored in memory during session
                document.getElementById('playerName').value = this.playerName;
                document.getElementById('soundToggle').value = this.soundEnabled.toString();
            }
            
            saveSettings() {
                const name = document.getElementById('playerName').value.trim() || 'Player';
                const sound = document.getElementById('soundToggle').value === 'true';
                
                this.playerName = name;
                this.soundEnabled = sound;
                this.localPlayer.name = name;
                
                // Settings saved in memory for the session
                
                this.showMainMenu();
            }
            
            setupEventListeners() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Escape' && this.gameState === 'playing') {
                        this.pauseGame();
                    }
                    if (e.code === 'Enter' && document.activeElement.id === 'chatInput') {
                        this.sendChatMessage();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Mouse
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left + this.camera.x;
                    this.mouse.y = e.clientY - rect.top + this.camera.y;
                });
                
                this.canvas.addEventListener('mousedown', (e) => {
                    if (this.gameState === 'playing') {
                        this.mouse.down = true;
                        this.shoot();
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.mouse.down = false;
                });
                
                // Right click for special ability
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (this.gameState === 'playing') {
                        this.useSpecial();
                    }
                });
                
                // Mobile controls
                const shootBtn = document.getElementById('shootBtn');
                if (shootBtn) {
                    shootBtn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        if (this.gameState === 'playing') {
                            this.shoot();
                        }
                    });
                }

                // Chat input
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    chatInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.sendChatMessage();
                        }
                    });
                }
            }
            
            setupMobileControls() {
                const container = document.getElementById('joystickContainer');
                const knob = document.getElementById('joystickKnob');
                
                const handleStart = (e) => {
                    e.preventDefault();
                    const rect = container.getBoundingClientRect();
                    this.joystick.centerX = rect.left + rect.width / 2;
                    this.joystick.centerY = rect.top + rect.height / 2;
                    this.joystick.active = true;
                    
                    const touch = e.touches ? e.touches[0] : e;
                    this.updateJoystick(touch.clientX, touch.clientY);
                };
                
                const handleMove = (e) => {
                    if (!this.joystick.active) return;
                    e.preventDefault();
                    const touch = e.touches ? e.touches[0] : e;
                    this.updateJoystick(touch.clientX, touch.clientY);
                };
                
                const handleEnd = (e) => {
                    e.preventDefault();
                    this.joystick.active = false;
                    this.joystick.x = 0;
                    this.joystick.y = 0;
                    knob.style.transform = 'translate(-50%, -50%)';
                };
                
                container.addEventListener('touchstart', handleStart);
                container.addEventListener('touchmove', handleMove);
                container.addEventListener('touchend', handleEnd);
                container.addEventListener('mousedown', handleStart);
                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleEnd);
            }
            
            updateJoystick(clientX, clientY) {
                const dx = clientX - this.joystick.centerX;
                const dy = clientY - this.joystick.centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = 35;
                
                if (distance > maxDistance) {
                    this.joystick.x = (dx / distance) * maxDistance;
                    this.joystick.y = (dy / distance) * maxDistance;
                } else {
                    this.joystick.x = dx;
                    this.joystick.y = dy;
                }
                
                const knob = document.getElementById('joystickKnob');
                knob.style.transform = `translate(calc(-50% + ${this.joystick.x}px), calc(-50% + ${this.joystick.y}px))`;
            }
            
            // Copy/Paste functionality
            async copyRoomCode() {
                try {
                    await navigator.clipboard.writeText(this.roomCode);
                    alert('Room code copied to clipboard!');
                } catch (err) {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = this.roomCode;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    alert('Room code copied to clipboard!');
                }
            }
            
            async pasteRoomCode() {
                try {
                    const text = await navigator.clipboard.readText();
                    document.getElementById('roomCodeInput').value = text.trim().toUpperCase();
                } catch (err) {
                    alert('Please paste the room code manually.');
                }
            }

            // Menu functions
            showMainMenu() {
                this.gameState = 'menu';
                this.hideAllMenus();
                if (this.currentUser) {
                    document.getElementById('mainMenu').classList.remove('hidden');
                } else {
                    document.getElementById('loginScreen').classList.remove('hidden');
                }
                this.cleanupConnections();
            }
            
            cleanupConnections() {
                this.connections.forEach(conn => conn.close());
                this.connections.clear();
                if (this.connection) {
                    this.connection.close();
                    this.connection = null;
                }
                if (this.peer) {
                    this.peer.destroy();
                    this.peer = null;
                }
            }
            
            showHostMenu() {
                if (!this.selectedCharacter) {
                    this.showCharacterSelection('host');
                    return;
                }
                this.hideAllMenus();
                document.getElementById('hostMenu').classList.remove('hidden');
                this.createHost();
            }
            
            showJoinMenu() {
                if (!this.selectedCharacter) {
                    this.showCharacterSelection('join');
                    return;
                }
                this.hideAllMenus();
                document.getElementById('joinMenu').classList.remove('hidden');
            }
            
            showCharacterSelection(returnTo = 'menu') {
                this.hideAllMenus();
                document.getElementById('characterSelection').classList.remove('hidden');
                this.returnTo = returnTo;
                this.renderCharacterSelection();
            }
            
            renderCharacterSelection() {
                const grid = document.getElementById('characterGrid');
                grid.innerHTML = '';
                
                Object.values(CHARACTERS).forEach(char => {
                    const card = document.createElement('div');
                    card.className = 'character-card';
                    if (this.selectedCharacter && this.selectedCharacter.id === char.id) {
                        card.classList.add('selected');
                    }
                    
                    card.innerHTML = `
                        <div class="character-avatar">${char.avatar}</div>
                        <div><strong>${char.name}</strong></div>
                        <div style="font-size: 12px; color: var(--color-text-secondary); margin-top: 4px;">
                            ${char.attack.type.toUpperCase()}
                        </div>
                    `;
                    
                    card.addEventListener('click', () => this.selectCharacter(char));
                    grid.appendChild(card);
                });
                
                this.updateCharacterInfo();
            }
            
            selectCharacter(character) {
                this.selectedCharacter = character;
                this.localPlayer.character = character;
                this.localPlayer.maxHealth = character.health;
                this.localPlayer.health = character.health;
                
                this.renderCharacterSelection();
                this.updateCharacterInfo();
                document.getElementById('confirmCharacterBtn').disabled = false;
            }
            
            updateCharacterInfo() {
                const info = document.getElementById('characterInfo');
                if (!this.selectedCharacter) {
                    info.innerHTML = '<p>Select a character to see their stats</p>';
                    return;
                }
                
                const char = this.selectedCharacter;
                info.innerHTML = `
                    <h4>${char.name}</h4>
                    <p><strong>Special:</strong> ${char.special.effect}</p>
                    <div class="character-stats">
                        <div class="stat-item">
                            <span>Health:</span>
                            <span>${char.health}</span>
                        </div>
                        <div class="stat-item">
                            <span>Speed:</span>
                            <span>${char.speed}</span>
                        </div>
                        <div class="stat-item">
                            <span>Damage:</span>
                            <span>${char.attack.damage}</span>
                        </div>
                        <div class="stat-item">
                            <span>Fire Rate:</span>
                            <span>${char.attack.fire_rate}ms</span>
                        </div>
                    </div>
                `;
            }
            
            confirmCharacter() {
                if (!this.selectedCharacter) return;
                
                if (this.returnTo === 'host') {
                    this.showHostMenu();
                } else if (this.returnTo === 'join') {
                    this.showJoinMenu();
                } else {
                    this.showMainMenu();
                }
            }
            
            showSettings() {
                this.hideAllMenus();
                document.getElementById('settingsMenu').classList.remove('hidden');
            }
            
            showInstructions() {
                this.hideAllMenus();
                document.getElementById('instructionsMenu').classList.remove('hidden');
            }
            
            hideAllMenus() {
                const menus = [
                    'loginScreen', 'mainMenu', 'hostMenu', 'joinMenu', 'settingsMenu', 
                    'instructionsMenu', 'characterSelection', 'lobbyMenu', 'gameOverMenu'
                ];
                menus.forEach(id => {
                    document.getElementById(id).classList.add('hidden');
                });
            }
            
            // Lobby functions
            showLobby() {
                this.hideAllMenus();
                document.getElementById('lobbyMenu').classList.remove('hidden');
                this.updateLobbyUI();
                
                if (this.isHost) {
                    document.getElementById('hostControls').classList.remove('hidden');
                }
            }
            
            updateLobbyUI() {
                const playerList = document.getElementById('playerList');
                playerList.innerHTML = '';
                
                // Add local player
                const localItem = document.createElement('div');
                localItem.className = 'player-item';
                localItem.innerHTML = `
                    <div class="player-avatar">${this.selectedCharacter ? this.selectedCharacter.avatar : '?'}</div>
                    <div class="player-info">
                        <div>${this.playerName} ${this.isHost ? '(Host)' : ''}</div>
                        <div class="player-character">${this.selectedCharacter ? this.selectedCharacter.name : 'No character'}</div>
                    </div>
                `;
                playerList.appendChild(localItem);
                
                // Add remote players
                this.remotePlayers.forEach(player => {
                    const item = document.createElement('div');
                    item.className = 'player-item';
                    item.innerHTML = `
                        <div class="player-avatar">${player.character ? player.character.avatar : '?'}</div>
                        <div class="player-info">
                            <div>${player.name}</div>
                            <div class="player-character">${player.character ? player.character.name : 'Selecting...'}</div>
                        </div>
                    `;
                    playerList.appendChild(item);
                });
                
                document.getElementById('playerCount').textContent = this.remotePlayers.size + 1;
            }
            
            sendChatMessage() {
                const input = document.getElementById('chatInput');
                const message = input.value.trim();
                if (!message) return;
                
                const chatMessage = {
                    sender: this.playerName,
                    text: message,
                    timestamp: Date.now()
                };
                
                this.addChatMessage(chatMessage);
                input.value = '';
                
                // Send to all connected players
                this.broadcastMessage({
                    type: 'chat',
                    message: chatMessage
                });
            }
            
            addChatMessage(message) {
                this.chatMessages.push(message);
                if (this.chatMessages.length > 50) {
                    this.chatMessages.shift();
                }
                
                const container = document.getElementById('chatMessages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message';
                
                const timeStr = new Date(message.timestamp || Date.now()).toLocaleTimeString('pt-BR', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                messageDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        ${message.senderPhoto ? `<img src="${message.senderPhoto}" style="width: 20px; height: 20px; border-radius: 50%; border: 1px solid var(--color-border);" alt="Avatar">` : ''}
                        <span class="chat-sender">${message.sender}</span>
                        <span style="font-size: 11px; color: var(--color-text-secondary);">${timeStr}</span>
                    </div>
                    <div style="margin-left: ${message.senderPhoto ? '28px' : '0'}; word-wrap: break-word;">${message.text}</div>
                `;
                container.appendChild(messageDiv);
                container.scrollTop = container.scrollHeight;
            }
            
            startMatchFromLobby() {
                const mode = document.getElementById('gameModeSelect').value;
                this.gameMode = mode;
                
                this.broadcastMessage({
                    type: 'start_game',
                    mode: mode,
                    map: this.currentMap.id
                });
                
                this.startGame();
            }
            
            initializeGameMode() {
                switch (this.gameMode) {
                    case 'bots':
                        // Spawn bots
                        const botCount = GAME_MODES.bots.bot_count;
                        for (let i = 0; i < botCount; i++) {
                            const bot = this.createBot(`bot_${i}`, GAME_MODES.bots.bot_difficulty);
                            this.bots.push(bot);
                        }
                        break;
                        
                    case 'zombies':
                        // Initialize zombie mode
                        this.waveNumber = 1;
                        this.zombiesKilled = 0;
                        this.gameTimer = 0;
                        this.spawnZombieWave();
                        break;
                        
                    case 'team_vs_team':
                        // Assign teams
                        this.localPlayer.team = 1;
                        let teamAssignment = 2;
                        this.remotePlayers.forEach(player => {
                            player.team = teamAssignment;
                            teamAssignment = teamAssignment === 1 ? 2 : 1;
                        });
                        break;
                }
            }
            
            returnToLobby() {
                this.gameState = 'lobby';
                this.showLobby();
                
                // Reset game state
                this.localPlayer.health = this.selectedCharacter.health;
                this.localPlayer.score = 0;
                this.localPlayer.isAlive = true;
                this.bullets = [];
                this.particles = [];
                
                this.broadcastMessage({
                    type: 'return_lobby'
                });
            }

            // Networking
            createHost() {
                this.isHost = true;
                this.roomCode = this.generateRoomCode();
                
                document.getElementById('hostStatus').textContent = 'Creating room...';
                
                this.peer = new Peer(this.roomCode, {
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });
                
                this.peer.on('open', (id) => {
                    document.getElementById('hostStatus').textContent = 'Room created!';
                    document.getElementById('roomCodeDisplay').textContent = this.roomCode;
                    document.getElementById('roomCodeContainer').classList.remove('hidden');
                    document.getElementById('waitingMessage').classList.remove('hidden');
                    this.setupRoomChat(); // Initialize Firebase chat
                });
                
                this.peer.on('connection', (conn) => {
                    this.setupConnection(conn);
                    document.getElementById('hostStatus').textContent = 'Player connected! Moving to lobby...';
                    setTimeout(() => this.showLobby(), 2000);
                });
                
                this.peer.on('error', (err) => {
                    document.getElementById('hostStatus').textContent = 'Error: ' + err.message;
                    document.getElementById('hostStatus').className = 'status status-error';
                });
            }
            
            // Bot AI System
            createBot(id, difficulty = 'medium') {
                const characters = Object.values(CHARACTERS);
                const randomChar = characters[Math.floor(Math.random() * characters.length)];
                
                const difficultySettings = {
                    easy: { aimAccuracy: 0.3, reactionTime: 800, shootFrequency: 0.4 },
                    medium: { aimAccuracy: 0.6, reactionTime: 500, shootFrequency: 0.7 },
                    hard: { aimAccuracy: 0.8, reactionTime: 200, shootFrequency: 0.9 }
                };
                
                const settings = difficultySettings[difficulty] || difficultySettings.medium;
                
                return {
                    id: id,
                    name: `Bot ${id}`,
                    character: randomChar,
                    x: 200 + Math.random() * 600,
                    y: 200 + Math.random() * 400,
                    health: randomChar.health,
                    maxHealth: randomChar.health,
                    angle: 0,
                    score: 0,
                    isAlive: true,
                    isBot: true,
                    difficulty: difficulty,
                    ...settings,
                    lastShot: 0,
                    lastSpecial: 0,
                    target: null,
                    lastTargetUpdate: 0,
                    pathfinding: {
                        targetX: 200 + Math.random() * 600,
                        targetY: 200 + Math.random() * 400,
                        lastPathUpdate: 0
                    }
                };
            }
            
            updateBots(deltaTime) {
                const now = Date.now();
                if (now - this.lastBotUpdate < this.botUpdateInterval) return;
                this.lastBotUpdate = now;
                
                this.bots.forEach(bot => {
                    if (!bot.isAlive) return;
                    
                    this.updateBotAI(bot, deltaTime);
                    this.updateBotMovement(bot, deltaTime);
                    this.updateBotCombat(bot, deltaTime);
                });
            }
            
            updateBotAI(bot, deltaTime) {
                const now = Date.now();
                
                // Update target every 500ms
                if (now - bot.lastTargetUpdate > 500) {
                    bot.lastTargetUpdate = now;
                    
                    let nearestTarget = null;
                    let nearestDistance = Infinity;
                    
                    // Check local player
                    if (this.localPlayer.isAlive) {
                        const dx = this.localPlayer.x - bot.x;
                        const dy = this.localPlayer.y - bot.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < nearestDistance && dist < 300) {
                            nearestDistance = dist;
                            nearestTarget = this.localPlayer;
                        }
                    }
                    
                    // Check remote players
                    this.remotePlayers.forEach(player => {
                        if (!player.isAlive) return;
                        
                        const dx = player.x - bot.x;
                        const dy = player.y - bot.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < nearestDistance && dist < 300) {
                            nearestDistance = dist;
                            nearestTarget = player;
                        }
                    });
                    
                    bot.target = nearestTarget;
                }
                
                // Update pathfinding if no target
                if (!bot.target && now - bot.pathfinding.lastPathUpdate > 2000) {
                    bot.pathfinding.lastPathUpdate = now;
                    bot.pathfinding.targetX = 100 + Math.random() * (this.currentMap.width - 200);
                    bot.pathfinding.targetY = 100 + Math.random() * (this.currentMap.height - 200);
                }
            }
            
            updateBotMovement(bot, deltaTime) {
                let targetX, targetY;
                
                if (bot.target) {
                    // Move towards or away from target based on strategy
                    const dx = bot.target.x - bot.x;
                    const dy = bot.target.y - bot.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 150) {
                        // Move closer
                        targetX = bot.x + (dx / dist) * 100;
                        targetY = bot.y + (dy / dist) * 100;
                    } else if (dist < 80) {
                        // Back away
                        targetX = bot.x - (dx / dist) * 100;
                        targetY = bot.y - (dy / dist) * 100;
                    } else {
                        // Strafe around target
                        const perpX = -dy / dist;
                        const perpY = dx / dist;
                        targetX = bot.x + perpX * 50;
                        targetY = bot.y + perpY * 50;
                    }
                } else {
                    // Move to pathfinding target
                    targetX = bot.pathfinding.targetX;
                    targetY = bot.pathfinding.targetY;
                }
                
                // Move towards target
                const moveX = targetX - bot.x;
                const moveY = targetY - bot.y;
                const moveDist = Math.sqrt(moveX * moveX + moveY * moveY);
                
                if (moveDist > 5) {
                    const speed = bot.character.speed * deltaTime;
                    const newX = bot.x + (moveX / moveDist) * speed;
                    const newY = bot.y + (moveY / moveDist) * speed;
                    
                    // Check collision
                    if (this.canMoveToBot(newX, bot.y)) {
                        bot.x = newX;
                    }
                    if (this.canMoveToBot(bot.x, newY)) {
                        bot.y = newY;
                    }
                }
                
                // Update angle to face target
                if (bot.target) {
                    const dx = bot.target.x - bot.x;
                    const dy = bot.target.y - bot.y;
                    bot.angle = Math.atan2(dy, dx);
                }
            }
            
            canMoveToBot(x, y) {
                const botRect = {
                    x: x - this.PLAYER_SIZE,
                    y: y - this.PLAYER_SIZE,
                    w: this.PLAYER_SIZE * 2,
                    h: this.PLAYER_SIZE * 2
                };
                
                // Check map bounds
                if (x < this.PLAYER_SIZE || x > this.currentMap.width - this.PLAYER_SIZE ||
                    y < this.PLAYER_SIZE || y > this.currentMap.height - this.PLAYER_SIZE) {
                    return false;
                }
                
                // Check obstacles
                return !this.obstacles.some(obstacle => {
                    if (obstacle.destroyed) return false;
                    return this.checkRectCollision(botRect, obstacle);
                });
            }
            
            updateBotCombat(bot, deltaTime) {
                if (!bot.target || !bot.isAlive) return;
                
                const now = Date.now();
                const dx = bot.target.x - bot.x;
                const dy = bot.target.y - bot.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Shooting logic
                if (distance < bot.character.attack.range) {
                    const fireRate = bot.character.attack.fire_rate;
                    if (now - bot.lastShot > fireRate && Math.random() < bot.shootFrequency) {
                        bot.lastShot = now;
                        
                        // Add aim inaccuracy
                        const accuracy = bot.aimAccuracy;
                        const maxError = (1 - accuracy) * 0.5; // Max error in radians
                        const errorAngle = (Math.random() - 0.5) * maxError;
                        const adjustedAngle = bot.angle + errorAngle;
                        
                        // Create bot bullet
                        const bullet = {
                            x: bot.x + Math.cos(adjustedAngle) * 20,
                            y: bot.y + Math.sin(adjustedAngle) * 20,
                            vx: Math.cos(adjustedAngle) * this.BULLET_SPEED,
                            vy: Math.sin(adjustedAngle) * this.BULLET_SPEED,
                            owner: bot.id,
                            damage: bot.character.attack.damage,
                            trail: [],
                            id: Math.random().toString(36)
                        };
                        
                        this.bullets.push(bullet);
                        this.createMuzzleFlash(bot.x, bot.y, adjustedAngle);
                    }
                }
                
                // Special ability logic
                if (now - bot.lastSpecial > 8000 && Math.random() < 0.1) {
                    bot.lastSpecial = now;
                    this.performBotSpecial(bot);
                }
            }
            
            performBotSpecial(bot) {
                const special = bot.character.special;
                
                switch (special.type) {
                    case 'dash':
                    case 'stealth_dash':
                        const distance = 80;
                        const newX = bot.x + Math.cos(bot.angle) * distance;
                        const newY = bot.y + Math.sin(bot.angle) * distance;
                        
                        if (this.canMoveToBot(newX, newY)) {
                            bot.x = newX;
                            bot.y = newY;
                        }
                        this.createDashEffect(bot.x, bot.y);
                        break;
                        
                    case 'shockwave':
                        this.createShockwaveEffect(bot.x, bot.y, 80);
                        // Damage nearby players
                        if (this.localPlayer.isAlive) {
                            const dx = this.localPlayer.x - bot.x;
                            const dy = this.localPlayer.y - bot.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < 80) {
                                this.localPlayer.health -= 40;
                                this.createBloodEffect(this.localPlayer.x, this.localPlayer.y);
                                if (this.localPlayer.health <= 0) {
                                    this.playerDied(this.localPlayer.id);
                                    bot.score++;
                                }
                            }
                        }
                        break;
                }
            }
            
            // Zombie System
            createZombie(id) {
                return {
                    id: id,
                    name: `Zombie ${id}`,
                    avatar: 'üßü',
                    x: Math.random() < 0.5 ? -50 : this.currentMap.width + 50,
                    y: 100 + Math.random() * (this.currentMap.height - 200),
                    health: 60 + (this.waveNumber * 10),
                    maxHealth: 60 + (this.waveNumber * 10),
                    speed: 80 + (this.waveNumber * 5),
                    damage: 30 + (this.waveNumber * 5),
                    angle: 0,
                    isAlive: true,
                    isZombie: true,
                    target: null,
                    lastAttack: 0,
                    attackRange: 25
                };
            }
            
            updateZombies(deltaTime) {
                if (this.gameMode !== 'zombies' || this.gameState !== 'playing') return;
                
                this.zombies.forEach((zombie, index) => {
                    if (!zombie.isAlive) return;
                    
                    this.updateZombieAI(zombie, deltaTime);
                    this.updateZombieMovement(zombie, deltaTime);
                    this.updateZombieCombat(zombie);
                });
            }
            
            updateZombieAI(zombie, deltaTime) {
                let nearestTarget = null;
                let nearestDistance = Infinity;
                
                // Find nearest human player
                if (this.localPlayer.isAlive) {
                    const dx = this.localPlayer.x - zombie.x;
                    const dy = this.localPlayer.y - zombie.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < nearestDistance) {
                        nearestDistance = dist;
                        nearestTarget = this.localPlayer;
                    }
                }
                
                this.remotePlayers.forEach(player => {
                    if (!player.isAlive) return;
                    
                    const dx = player.x - zombie.x;
                    const dy = player.y - zombie.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < nearestDistance) {
                        nearestDistance = dist;
                        nearestTarget = player;
                    }
                });
                
                zombie.target = nearestTarget;
                
                if (zombie.target) {
                    const dx = zombie.target.x - zombie.x;
                    const dy = zombie.target.y - zombie.y;
                    zombie.angle = Math.atan2(dy, dx);
                }
            }
            
            updateZombieMovement(zombie, deltaTime) {
                if (!zombie.target) return;
                
                const dx = zombie.target.x - zombie.x;
                const dy = zombie.target.y - zombie.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > zombie.attackRange) {
                    const speed = zombie.speed * deltaTime;
                    const newX = zombie.x + (dx / dist) * speed;
                    const newY = zombie.y + (dy / dist) * speed;
                    
                    // Simple collision check
                    if (this.canMoveToBot(newX, zombie.y)) {
                        zombie.x = newX;
                    }
                    if (this.canMoveToBot(zombie.x, newY)) {
                        zombie.y = newY;
                    }
                }
            }
            
            updateZombieCombat(zombie) {
                if (!zombie.target || !zombie.isAlive) return;
                
                const now = Date.now();
                const dx = zombie.target.x - zombie.x;
                const dy = zombie.target.y - zombie.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < zombie.attackRange && now - zombie.lastAttack > 1000) {
                    zombie.lastAttack = now;
                    
                    // Damage target
                    if (zombie.target === this.localPlayer) {
                        this.localPlayer.health -= zombie.damage;
                        this.createBloodEffect(this.localPlayer.x, this.localPlayer.y);
                        
                        if (this.localPlayer.health <= 0) {
                            this.playerDied(this.localPlayer.id);
                        }
                    }
                    
                    // Visual effect
                    this.createHitEffect(zombie.x, zombie.y);
                }
            }
            
            spawnZombieWave() {
                if (this.gameMode !== 'zombies') return;
                
                const zombieCount = Math.floor(GAME_MODES.zombies.zombies_per_wave * Math.pow(GAME_MODES.zombies.wave_multiplier, this.waveNumber - 1));
                
                for (let i = 0; i < zombieCount; i++) {
                    const zombie = this.createZombie(`zombie_${this.waveNumber}_${i}`);
                    this.zombies.push(zombie);
                }
                
                // Add system message
                this.addChatMessage({
                    sender: 'Sistema',
                    text: `Onda ${this.waveNumber} iniciada! ${zombieCount} zumbis apareceram!`,
                    timestamp: Date.now(),
                    senderPhoto: null
                });
            }
            
            // Game Mode Logic
            updateGameMode(deltaTime) {
                if (this.gameState !== 'playing') return;
                
                this.gameTimer += deltaTime * 1000;
                
                switch (this.gameMode) {
                    case 'zombies':
                        this.updateZombieMode();
                        break;
                        
                    case 'bots':
                        this.updateBotMode();
                        break;
                        
                    case 'team_vs_team':
                        this.updateTeamMode();
                        break;
                }
            }
            
            updateZombieMode() {
                const mode = GAME_MODES.zombies;
                
                // Check if wave is complete
                const aliveZombies = this.zombies.filter(z => z.isAlive).length;
                
                if (aliveZombies === 0 && this.gameTimer > mode.wave_duration) {
                    this.waveNumber++;
                    this.gameTimer = 0;
                    this.spawnZombieWave();
                }
                
                // Check if all players are dead
                const alivePlayers = [this.localPlayer].concat(Array.from(this.remotePlayers.values())).filter(p => p.isAlive).length;
                
                if (alivePlayers === 0) {
                    this.endZombieGame();
                }
            }
            
            updateBotMode() {
                const mode = GAME_MODES.bots;
                
                // Check if survive time reached
                if (this.gameTimer >= mode.win_target) {
                    this.endGame('Sobreviveram ao tempo limite!');
                }
                
                // Check if all players dead
                const alivePlayers = [this.localPlayer].concat(Array.from(this.remotePlayers.values())).filter(p => p.isAlive).length;
                
                if (alivePlayers === 0) {
                    this.endGame('Todos os jogadores foram eliminados!');
                }
            }
            
            updateTeamMode() {
                const mode = GAME_MODES.team_vs_team;
                
                // Update team scores
                let team1Score = 0, team2Score = 0;
                
                if (this.localPlayer.team === 1) team1Score += this.localPlayer.score;
                else team2Score += this.localPlayer.score;
                
                this.remotePlayers.forEach(player => {
                    if (player.team === 1) team1Score += player.score;
                    else team2Score += player.score;
                });
                
                this.teamScores.team1 = team1Score;
                this.teamScores.team2 = team2Score;
                
                // Check win condition
                if (team1Score >= mode.win_target) {
                    this.endGame('Equipe Azul Venceu!');
                } else if (team2Score >= mode.win_target) {
                    this.endGame('Equipe Vermelha Venceu!');
                }
            }
            
            endZombieGame() {
                this.gameState = 'gameOver';
                this.hideAllMenus();
                document.getElementById('gameOverMenu').classList.remove('hidden');
                
                document.getElementById('gameOverTitle').textContent = `Sobreviveram ${this.waveNumber - 1} ondas!`;
                
                const stats = document.getElementById('gameOverStats');
                stats.innerHTML = `
                    <h3>Estat√≠sticas Finais</h3>
                    <div>Ondas Sobrevividas: ${this.waveNumber - 1}</div>
                    <div>Zumbis Eliminados: ${this.zombiesKilled}</div>
                    <div>Tempo Sobrevivido: ${Math.floor(this.gameTimer / 60000)}:${Math.floor((this.gameTimer % 60000) / 1000).toString().padStart(2, '0')}</div>
                `;
            }
            
            joinRoom() {
                const code = document.getElementById('roomCodeInput').value.trim().toUpperCase();
                if (!code) return;
                
                this.isHost = false;
                this.roomCode = code;
                document.getElementById('joinStatus').classList.remove('hidden');
                document.getElementById('joinStatus').textContent = 'Connecting...';
                
                this.peer = new Peer({
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });
                
                this.peer.on('open', () => {
                    const conn = this.peer.connect(code);
                    this.connection = conn;
                    this.setupConnection(conn);
                });
                
                this.peer.on('error', (err) => {
                    document.getElementById('joinStatus').textContent = 'Connection failed: ' + err.message;
                    document.getElementById('joinStatus').className = 'status status-error';
                });
            }
            
            setupConnection(conn) {
                if (!this.isHost) {
                    this.connection = conn;
                }
                
                const connection = conn || this.connection;
                const playerId = connection.peer;
                
                connection.on('open', () => {
                    if (this.isHost) {
                        this.connections.set(playerId, connection);
                        
                        // Send initial lobby state
                        connection.send({
                            type: 'lobby_state',
                            players: Array.from(this.remotePlayers.values()),
                            messages: this.chatMessages
                        });
                        
                        document.getElementById('hostStatus').textContent = 'Connected! Moving to lobby...';
                    } else {
                        document.getElementById('joinStatus').textContent = 'Connected! Joining lobby...';
                        document.getElementById('joinStatus').className = 'status status-success';
                        
                        // Send player info
                        connection.send({
                            type: 'player_join',
                            name: this.playerName,
                            character: this.selectedCharacter
                        });
                    }
                });
                
                connection.on('data', (data) => {
                    this.handleNetworkMessage(data, playerId);
                });
                
                connection.on('close', () => {
                    if (this.isHost) {
                        this.connections.delete(playerId);
                        this.remotePlayers.delete(playerId);
                        this.updateLobbyUI();
                    } else {
                        alert('Connection lost! Returning to menu.');
                        this.showMainMenu();
                    }
                });
            }
            
            broadcastMessage(message) {
                if (this.isHost) {
                    this.connections.forEach(conn => {
                        if (conn.open) {
                            conn.send(message);
                        }
                    });
                } else if (this.connection && this.connection.open) {
                    this.connection.send(message);
                }
            }
            
            generateRoomCode() {
                return Math.random().toString(36).substring(2, 8).toUpperCase();
            }
            
            // Game logic
            startGame() {
                this.gameState = 'playing';
                this.hideAllMenus();
                document.getElementById('gameContainer').style.display = 'block';
                
                // Setup canvas size based on map
                this.canvas.width = Math.min(this.currentMap.width, window.innerWidth - 40);
                this.canvas.height = Math.min(this.currentMap.height, window.innerHeight - 40);
                
                // Reset game state
                this.localPlayer.health = this.selectedCharacter.health;
                this.localPlayer.maxHealth = this.selectedCharacter.health;
                this.localPlayer.score = 0;
                this.localPlayer.isAlive = true;
                this.localPlayer.name = this.playerName;
                
                // Random spawn position
                this.localPlayer.x = 100 + Math.random() * 200;
                this.localPlayer.y = 100 + Math.random() * 200;
                
                this.bullets = [];
                this.particles = [];
                this.loadMapObstacles();
                this.initializeGameMode();
                
                // Enable mobile controls if needed
                if (this.isMobile) {
                    document.querySelector('.mobile-controls').style.display = 'flex';
                }
                
                this.updateHUD();
                
                // Send initial state
                this.broadcastMessage({
                    type: 'game_start',
                    player: {
                        name: this.playerName,
                        character: this.selectedCharacter,
                        x: this.localPlayer.x,
                        y: this.localPlayer.y
                    }
                });
            }
            
            loadMapObstacles() {
                this.obstacles = this.currentMap.obstacles.map(obs => ({
                    ...obs,
                    destroyed: false
                }));
            }
            
            pauseGame() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                    document.getElementById('pauseMenu').classList.remove('hidden');
                }
            }
            
            resumeGame() {
                if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                    document.getElementById('pauseMenu').classList.add('hidden');
                }
            }
            
            updateGame(deltaTime) {
                if (this.gameState !== 'playing') return;
                
                this.updatePlayer(deltaTime);
                this.updateBullets(deltaTime);
                this.updateParticles(deltaTime);
                this.updateCamera(deltaTime);
                this.checkCollisions();
                this.sendNetworkUpdates();
                this.updateHUD();
                
                // Check win condition
                if (this.localPlayer.score >= this.WIN_SCORE) {
                    this.endGame();
                }
            }
            
            updateCamera(deltaTime) {
                // Smooth camera following
                this.cameraTarget.x = this.localPlayer.x - this.canvas.width / 2;
                this.cameraTarget.y = this.localPlayer.y - this.canvas.height / 2;
                
                // Clamp camera to map bounds
                this.cameraTarget.x = Math.max(0, Math.min(this.currentMap.width - this.canvas.width, this.cameraTarget.x));
                this.cameraTarget.y = Math.max(0, Math.min(this.currentMap.height - this.canvas.height, this.cameraTarget.y));
                
                // Smooth interpolation
                this.camera.x += (this.cameraTarget.x - this.camera.x) * this.CAMERA_SMOOTHING;
                this.camera.y += (this.cameraTarget.y - this.camera.y) * this.CAMERA_SMOOTHING;
            }
            
            updatePlayer(deltaTime) {
                if (!this.localPlayer.isAlive) return;
                
                let moveX = 0, moveY = 0;
                
                // Desktop controls
                if (this.keys['KeyW'] || this.keys['ArrowUp']) moveY -= 1;
                if (this.keys['KeyS'] || this.keys['ArrowDown']) moveY += 1;
                if (this.keys['KeyA'] || this.keys['ArrowLeft']) moveX -= 1;
                if (this.keys['KeyD'] || this.keys['ArrowRight']) moveX += 1;
                
                // Mobile joystick
                if (this.joystick.active) {
                    moveX = this.joystick.x / 35;
                    moveY = this.joystick.y / 35;
                }
                
                // Normalize diagonal movement
                if (moveX !== 0 || moveY !== 0) {
                    const length = Math.sqrt(moveX * moveX + moveY * moveY);
                    moveX /= length;
                    moveY /= length;
                }
                
                // Apply movement with character speed
                const speed = this.selectedCharacter.speed * deltaTime;
                const newX = this.localPlayer.x + moveX * speed;
                const newY = this.localPlayer.y + moveY * speed;
                
                // Check collision with obstacles
                if (this.canMoveTo(newX, this.localPlayer.y)) {
                    this.localPlayer.x = newX;
                }
                if (this.canMoveTo(this.localPlayer.x, newY)) {
                    this.localPlayer.y = newY;
                }
                
                // Boundary checking
                const margin = this.PLAYER_SIZE;
                this.localPlayer.x = Math.max(margin, Math.min(this.currentMap.width - margin, this.localPlayer.x));
                this.localPlayer.y = Math.max(margin, Math.min(this.currentMap.height - margin, this.localPlayer.y));
                
                // Update angle for aiming
                if (!this.joystick.active) {
                    const dx = this.mouse.x - this.localPlayer.x;
                    const dy = this.mouse.y - this.localPlayer.y;
                    this.localPlayer.angle = Math.atan2(dy, dx);
                } else {
                    // On mobile, aim towards movement direction
                    if (moveX !== 0 || moveY !== 0) {
                        this.localPlayer.angle = Math.atan2(moveY, moveX);
                    }
                }
            }
            
            canMoveTo(x, y) {
                const playerRect = {
                    x: x - this.PLAYER_SIZE,
                    y: y - this.PLAYER_SIZE,
                    w: this.PLAYER_SIZE * 2,
                    h: this.PLAYER_SIZE * 2
                };
                
                return !this.obstacles.some(obstacle => {
                    if (obstacle.destroyed) return false;
                    return this.checkRectCollision(playerRect, obstacle);
                });
            }
            
            checkRectCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.w &&
                       rect1.x + rect1.w > rect2.x &&
                       rect1.y < rect2.y + rect2.h &&
                       rect1.y + rect1.h > rect2.y;
            }
            
            shoot() {
                if (!this.localPlayer.isAlive) return;
                
                const now = Date.now();
                const fireRate = this.selectedCharacter.attack.fire_rate;
                if (now - this.localPlayer.lastShot < fireRate) return;
                
                this.localPlayer.lastShot = now;
                
                // Create bullets based on character type
                const bulletCount = this.selectedCharacter.attack.bullet_count;
                const damage = this.selectedCharacter.attack.damage;
                
                for (let i = 0; i < bulletCount; i++) {
                    let angle = this.localPlayer.angle;
                    
                    // Adjust angle for spread weapons
                    if (this.selectedCharacter.attack.type === 'shotgun' || this.selectedCharacter.attack.type === 'spread') {
                        const spread = 0.3; // radians
                        angle += (i - (bulletCount - 1) / 2) * (spread / bulletCount);
                    }
                    
                    const bullet = {
                        x: this.localPlayer.x + Math.cos(angle) * 20,
                        y: this.localPlayer.y + Math.sin(angle) * 20,
                        vx: Math.cos(angle) * this.BULLET_SPEED,
                        vy: Math.sin(angle) * this.BULLET_SPEED,
                        owner: 'local',
                        damage: damage,
                        trail: [],
                        id: Math.random().toString(36)
                    };
                    
                    this.bullets.push(bullet);
                    
                    // Send bullet to other players
                    this.broadcastMessage({
                        type: 'bullet',
                        bullet: bullet
                    });
                }
                
                // Visual effects
                this.createMuzzleFlash(this.localPlayer.x, this.localPlayer.y, this.localPlayer.angle);
            }
            
            useSpecial() {
                if (!this.localPlayer.isAlive) return;
                
                const now = Date.now();
                if (now - this.localPlayer.lastSpecial < this.SPECIAL_COOLDOWN) return;
                
                this.localPlayer.lastSpecial = now;
                
                const special = this.selectedCharacter.special;
                
                switch (special.type) {
                    case 'dash':
                        this.performDash();
                        break;
                    case 'range_shot':
                        this.performRangeShot();
                        break;
                    case 'shockwave':
                        this.performShockwave();
                        break;
                    case 'turret':
                        this.performTurret();
                        break;
                    case 'fire_wall':
                        this.performFireWall();
                        break;
                    case 'mass_heal':
                        this.performMassHeal();
                        break;
                    case 'blood_rage':
                        this.performBloodRage();
                        break;
                    case 'piercing_arrow':
                        this.performPiercingArrow();
                        break;
                    case 'headshot':
                        this.performHeadshot();
                        break;
                    case 'meteor':
                        this.performMeteor();
                        break;
                    case 'spin_attack':
                        this.performSpinAttack();
                        break;
                    case 'shield_slam':
                        this.performShieldSlam();
                        break;
                
                this.broadcastMessage({
                    type: 'special',
                    specialType: special.type,
                    x: this.localPlayer.x,
                    y: this.localPlayer.y,
                    angle: this.localPlayer.angle
                });
            }
            
            performDash() {
                const distance = 100;
                const newX = this.localPlayer.x + Math.cos(this.localPlayer.angle) * distance;
                const newY = this.localPlayer.y + Math.sin(this.localPlayer.angle) * distance;
                
                // Destroy obstacles in path
                this.obstacles.forEach(obstacle => {
                    if (obstacle.type === 'destructible') {
                        const dx = obstacle.x + obstacle.w/2 - this.localPlayer.x;
                        const dy = obstacle.y + obstacle.h/2 - this.localPlayer.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < distance) {
                            obstacle.destroyed = true;
                            this.createExplosionEffect(obstacle.x + obstacle.w/2, obstacle.y + obstacle.h/2);
                        }
                    }
                });
                
                if (this.canMoveTo(newX, newY)) {
                    this.localPlayer.x = newX;
                    this.localPlayer.y = newY;
                }
                
                this.createDashEffect(this.localPlayer.x, this.localPlayer.y);
            }
            
            performTurret() {
                // Engineer's turret ability
                const turret = {
                    id: Math.random().toString(36),
                    x: this.localPlayer.x + Math.cos(this.localPlayer.angle) * 40,
                    y: this.localPlayer.y + Math.sin(this.localPlayer.angle) * 40,
                    health: 100,
                    maxHealth: 100,
                    range: 200,
                    damage: 25,
                    fireRate: 500,
                    lastShot: 0,
                    ownerId: this.localPlayer.id,
                    lifespan: 30000, // 30 seconds
                    createdAt: Date.now()
                };
                
                this.turrets.push(turret);
                this.createExplosionEffect(turret.x, turret.y);
            }
            
            performFireWall() {
                // Pyro's fire wall ability
                const wallLength = 120;
                const wallWidth = 20;
                
                const fireWall = {
                    id: Math.random().toString(36),
                    x: this.localPlayer.x + Math.cos(this.localPlayer.angle) * 50 - wallWidth/2,
                    y: this.localPlayer.y + Math.sin(this.localPlayer.angle) * 50 - wallLength/2,
                    width: wallWidth,
                    height: wallLength,
                    damage: 15,
                    tickRate: 200,
                    lastTick: 0,
                    ownerId: this.localPlayer.id,
                    duration: 8000, // 8 seconds
                    createdAt: Date.now(),
                    angle: this.localPlayer.angle
                };
                
                this.fireWalls.push(fireWall);
                
                // Create visual effect
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        x: fireWall.x + Math.random() * fireWall.width,
                        y: fireWall.y + Math.random() * fireWall.height,
                        vx: (Math.random() - 0.5) * 50,
                        vy: (Math.random() - 0.5) * 50,
                        life: 2,
                        maxLife: 2,
                        alpha: 1,
                        color: '#ff4400',
                        size: 4,
                        type: 'fire'
                    });
                }
            }
            
            performMassHeal() {
                // Healer's mass heal ability
                const healRadius = 100;
                const healAmount = 50;
                
                // Heal local player
                if (this.localPlayer.isAlive) {
                    this.localPlayer.health = Math.min(this.localPlayer.maxHealth, this.localPlayer.health + healAmount);
                }
                
                // Heal nearby allies
                this.remotePlayers.forEach(player => {
                    if (!player.isAlive) return;
                    
                    const dx = player.x - this.localPlayer.x;
                    const dy = player.y - this.localPlayer.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < healRadius) {
                        player.health = Math.min(player.maxHealth, player.health + healAmount);
                        this.createHealEffect(player.x, player.y);
                    }
                });
                
                this.createHealEffect(this.localPlayer.x, this.localPlayer.y);
                this.createMassHealEffect(this.localPlayer.x, this.localPlayer.y, healRadius);
            }
            
            performBloodRage() {
                // Berserker's blood rage ability
                this.localPlayer.rageMode = true;
                this.localPlayer.rageDuration = 5000; // 5 seconds
                this.localPlayer.rageStartTime = Date.now();
                
                // Visual effect
                this.createRageEffect(this.localPlayer.x, this.localPlayer.y);
            }
            
            performPiercingArrow() {
                // Archer's piercing arrow
                const bullet = {
                    x: this.localPlayer.x,
                    y: this.localPlayer.y,
                    vx: Math.cos(this.localPlayer.angle) * this.BULLET_SPEED * 1.5,
                    vy: Math.sin(this.localPlayer.angle) * this.BULLET_SPEED * 1.5,
                    owner: 'local',
                    damage: 60,
                    trail: [],
                    piercing: true,
                    pierceCount: 0,
                    maxPierces: 3,
                    special: true,
                    id: Math.random().toString(36)
                };
                
                this.bullets.push(bullet);
            }
            
            performHeadshot() {
                // Sniper's precision headshot
                const bullet = {
                    x: this.localPlayer.x,
                    y: this.localPlayer.y,
                    vx: Math.cos(this.localPlayer.angle) * this.BULLET_SPEED * 2,
                    vy: Math.sin(this.localPlayer.angle) * this.BULLET_SPEED * 2,
                    owner: 'local',
                    damage: 150, // Massive damage
                    trail: [],
                    headshot: true,
                    special: true,
                    id: Math.random().toString(36)
                };
                
                this.bullets.push(bullet);
                this.createMuzzleFlash(this.localPlayer.x, this.localPlayer.y, this.localPlayer.angle);
            }
            
            performMeteor() {
                // Mage's meteor ability
                const targetX = this.localPlayer.x + Math.cos(this.localPlayer.angle) * 200;
                const targetY = this.localPlayer.y + Math.sin(this.localPlayer.angle) * 200;
                
                // Create meteor impact after delay
                setTimeout(() => {
                    this.createMeteorImpact(targetX, targetY);
                    
                    // Damage players in area
                    const damageRadius = 80;
                    this.remotePlayers.forEach(player => {
                        if (!player.isAlive) return;
                        
                        const dx = player.x - targetX;
                        const dy = player.y - targetY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < damageRadius) {
                            const damage = Math.max(20, 80 - dist);
                            player.health -= damage;
                            this.createBloodEffect(player.x, player.y);
                            
                            if (player.health <= 0) {
                                this.playerDied(player.id);
                                this.localPlayer.score++;
                            }
                        }
                    });
                }, 2000);
                
                // Visual indicator
                this.createMeteorWarning(targetX, targetY);
            }
            
            performSpinAttack() {
                // Warrior's spin attack
                const attackRadius = 60;
                
                this.remotePlayers.forEach(player => {
                    if (!player.isAlive) return;
                    
                    const dx = player.x - this.localPlayer.x;
                    const dy = player.y - this.localPlayer.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < attackRadius) {
                        player.health -= 70;
                        this.createBloodEffect(player.x, player.y);
                        
                        if (player.health <= 0) {
                            this.playerDied(player.id);
                            this.localPlayer.score++;
                        }
                    }
                });
                
                this.createSpinAttackEffect(this.localPlayer.x, this.localPlayer.y, attackRadius);
            }
            
            performShieldSlam() {
                // Tank's shield slam
                this.localPlayer.shieldMode = true;
                this.localPlayer.shieldDuration = 3000; // 3 seconds
                this.localPlayer.shieldStartTime = Date.now();
                
                // Knockback nearby enemies
                const knockbackRadius = 50;
                this.remotePlayers.forEach(player => {
                    if (!player.isAlive) return;
                    
                    const dx = player.x - this.localPlayer.x;
                    const dy = player.y - this.localPlayer.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < knockbackRadius && dist > 0) {
                        // Knockback effect (simulated)
                        player.health -= 40;
                        this.createBloodEffect(player.x, player.y);
                        
                        if (player.health <= 0) {
                            this.playerDied(player.id);
                            this.localPlayer.score++;
                        }
                    }
                });
                
                this.createShieldSlamEffect(this.localPlayer.x, this.localPlayer.y);
            }
            
            performRangeShot() {
                const bullet = {
                    x: this.localPlayer.x,
                    y: this.localPlayer.y,
                    vx: Math.cos(this.localPlayer.angle) * this.BULLET_SPEED * 2,
                    vy: Math.sin(this.localPlayer.angle) * this.BULLET_SPEED * 2,
                    owner: 'local',
                    damage: 50,
                    trail: [],
                    special: true,
                    id: Math.random().toString(36)
                };
                
                this.bullets.push(bullet);
            }
            
            performShockwave() {
                const radius = 80;
                this.remotePlayers.forEach(player => {
                    const dx = player.x - this.localPlayer.x;
                    const dy = player.y - this.localPlayer.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < radius && player.isAlive) {
                        player.health -= 40;
                        this.createHitEffect(player.x, player.y);
                        
                        if (player.health <= 0) {
                            this.playerDied(player.id);
                            this.localPlayer.score++;
                        }
                    }
                });
                
                this.createShockwaveEffect(this.localPlayer.x, this.localPlayer.y, radius);
            }
            
            updateBullets(deltaTime) {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    
                    // Add to trail
                    bullet.trail.push({ x: bullet.x, y: bullet.y });
                    if (bullet.trail.length > this.TRAIL_LENGTH) {
                        bullet.trail.shift();
                    }
                    
                    bullet.x += bullet.vx * deltaTime;
                    bullet.y += bullet.vy * deltaTime;
                    
                    // Check collision with obstacles
                    let hitObstacle = false;
                    for (const obstacle of this.obstacles) {
                        if (obstacle.destroyed) continue;
                        
                        if (bullet.x >= obstacle.x && bullet.x <= obstacle.x + obstacle.w &&
                            bullet.y >= obstacle.y && bullet.y <= obstacle.y + obstacle.h) {
                            
                            // Destroy destructible obstacles
                            if (obstacle.type === 'destructible') {
                                obstacle.destroyed = true;
                                this.createExplosionEffect(obstacle.x + obstacle.w/2, obstacle.y + obstacle.h/2);
                            } else {
                                // Create fragment effect for walls
                                this.createFragmentEffect(bullet.x, bullet.y, bullet.vx, bullet.vy);
                            }
                            
                            hitObstacle = true;
                            break;
                        }
                    }
                    
                    // Remove bullets that hit obstacles or are off-screen
                    if (hitObstacle || 
                        bullet.x < -100 || bullet.x > this.currentMap.width + 100 ||
                        bullet.y < -100 || bullet.y > this.currentMap.height + 100) {
                        this.bullets.splice(i, 1);
                    }
                }
            }
            
            updateParticles(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.x += particle.vx * deltaTime;
                    particle.y += particle.vy * deltaTime;
                    particle.life -= deltaTime;
                    particle.alpha = particle.life / particle.maxLife;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            checkCollisions() {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    let hit = false;
                    
                    // Check collision with local player (from remote bullets)
                    if (bullet.owner !== 'local' && this.localPlayer.isAlive) {
                        const dx = bullet.x - this.localPlayer.x;
                        const dy = bullet.y - this.localPlayer.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.PLAYER_SIZE) {
                            this.localPlayer.health -= bullet.damage || 20;
                            this.createBloodEffect(this.localPlayer.x, this.localPlayer.y);
                            hit = true;
                            
                            if (this.localPlayer.health <= 0) {
                                this.playerDied(this.localPlayer.id);
                            }
                            
                            this.broadcastMessage({
                                type: 'hit',
                                damage: bullet.damage,
                                targetId: this.localPlayer.id,
                                targetHealth: this.localPlayer.health
                            });
                        }
                    }
                    
                    // Check collision with remote players (from local bullets)
                    if (bullet.owner === 'local') {
                        this.remotePlayers.forEach((player, playerId) => {
                            if (!player.isAlive) return;
                            
                            const dx = bullet.x - player.x;
                            const dy = bullet.y - player.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < this.PLAYER_SIZE) {
                                player.health -= bullet.damage || 20;
                                this.createBloodEffect(player.x, player.y);
                                hit = true;
                                
                                if (player.health <= 0) {
                                    this.playerDied(playerId);
                                    this.localPlayer.score++;
                                }
                                
                                this.broadcastMessage({
                                    type: 'damage',
                                    playerId: playerId,
                                    damage: bullet.damage,
                                    health: player.health
                                });
                            }
                        });
                    }
                    
                    if (hit) {
                        this.bullets.splice(i, 1);
                    }
                }
            }
            
            playerDied(playerId) {
                if (playerId === this.localPlayer.id) {
                    this.localPlayer.isAlive = false;
                    this.localPlayer.health = 0;
                    this.createDeathEffect(this.localPlayer.x, this.localPlayer.y);
                    
                    setTimeout(() => {
                        this.localPlayer.isAlive = true;
                        this.localPlayer.health = this.selectedCharacter.health;
                        // Random respawn position
                        this.localPlayer.x = 100 + Math.random() * 200;
                        this.localPlayer.y = 100 + Math.random() * 200;
                        
                        this.broadcastMessage({
                            type: 'respawn',
                            x: this.localPlayer.x,
                            y: this.localPlayer.y
                        });
                    }, this.RESPAWN_TIME);
                } else {
                    const player = this.remotePlayers.get(playerId);
                    if (player) {
                        player.isAlive = false;
                        player.health = 0;
                        this.createDeathEffect(player.x, player.y);
                    }
                }
            }
            
            createMuzzleFlash(x, y, angle) {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x + Math.cos(angle) * 25,
                        y: y + Math.sin(angle) * 25,
                        vx: Math.cos(angle + (Math.random() - 0.5) * 0.5) * (100 + Math.random() * 50),
                        vy: Math.sin(angle + (Math.random() - 0.5) * 0.5) * (100 + Math.random() * 50),
                        life: 0.3 + Math.random() * 0.2,
                        maxLife: 0.3 + Math.random() * 0.2,
                        alpha: 1,
                        color: Math.random() > 0.5 ? '#ffaa00' : '#ff6600',
                        size: 2 + Math.random() * 4,
                        type: 'muzzle'
                    });
                }
            }
            
            createFragmentEffect(x, y, vx, vy) {
                for (let i = 0; i < 12; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * (80 + Math.random() * 40),
                        vy: Math.sin(angle) * (80 + Math.random() * 40),
                        life: 0.8 + Math.random() * 0.4,
                        maxLife: 0.8 + Math.random() * 0.4,
                        alpha: 1,
                        color: Math.random() > 0.5 ? '#888888' : '#aaaaaa',
                        size: 1 + Math.random() * 2,
                        type: 'fragment'
                    });
                }
            }
            
            createBloodEffect(x, y) {
                for (let i = 0; i < 15; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 20,
                        vx: Math.cos(angle) * (60 + Math.random() * 40),
                        vy: Math.sin(angle) * (60 + Math.random() * 40),
                        life: 1.5 + Math.random() * 0.5,
                        maxLife: 1.5 + Math.random() * 0.5,
                        alpha: 1,
                        color: Math.random() > 0.7 ? '#cc0000' : '#990000',
                        size: 2 + Math.random() * 3,
                        type: 'blood'
                    });
                }
            }
            
            createExplosionEffect(x, y) {
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * (100 + Math.random() * 50),
                        vy: Math.sin(angle) * (100 + Math.random() * 50),
                        life: 0.6,
                        maxLife: 0.6,
                        alpha: 1,
                        color: Math.random() > 0.5 ? '#ff4400' : '#ffaa00',
                        size: 3 + Math.random() * 4,
                        type: 'explosion'
                    });
                }
            }
            
            createDashEffect(x, y) {
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 30,
                        y: y + (Math.random() - 0.5) * 30,
                        vx: (Math.random() - 0.5) * 100,
                        vy: (Math.random() - 0.5) * 100,
                        life: 0.4,
                        maxLife: 0.4,
                        alpha: 1,
                        color: '#00aaff',
                        size: 3,
                        type: 'dash'
                    });
                }
            }
            
            createShockwaveEffect(x, y, radius) {
                for (let i = 0; i < 24; i++) {
                    const angle = (i / 24) * Math.PI * 2;
                    this.particles.push({
                        x: x + Math.cos(angle) * radius,
                        y: y + Math.sin(angle) * radius,
                        vx: Math.cos(angle) * 20,
                        vy: Math.sin(angle) * 20,
                        life: 0.5,
                        maxLife: 0.5,
                        alpha: 1,
                        color: '#aa00ff',
                        size: 4,
                        type: 'shockwave'
                    });
                }
            }
            
            createHitEffect(x, y) {
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 150,
                        vy: Math.sin(angle) * 150,
                        life: 0.5,
                        maxLife: 0.5,
                        alpha: 1,
                        color: '#ff4444',
                        size: 2,
                        type: 'hit'
                    });
                }
            }
            
            createDeathEffect(x, y) {
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * (50 + Math.random() * 100),
                        vy: Math.sin(angle) * (50 + Math.random() * 100),
                        life: 1,
                        maxLife: 1,
                        alpha: 1,
                        color: Math.random() > 0.5 ? '#ff4444' : '#ffaa00',
                        size: 3 + Math.random() * 3,
                        type: 'death'
                    });
                }
            }
            
            createHealEffect(x, y) {
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 30,
                        vy: Math.sin(angle) * 30 - 20,
                        life: 1,
                        maxLife: 1,
                        alpha: 1,
                        color: '#22c55e',
                        size: 3,
                        type: 'heal'
                    });
                }
            }
            
            createMassHealEffect(x, y, radius) {
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    this.particles.push({
                        x: x + Math.cos(angle) * radius,
                        y: y + Math.sin(angle) * radius,
                        vx: Math.cos(angle) * 20,
                        vy: Math.sin(angle) * 20,
                        life: 0.8,
                        maxLife: 0.8,
                        alpha: 1,
                        color: '#00ff88',
                        size: 4,
                        type: 'mass_heal'
                    });
                }
            }
            
            createRageEffect(x, y) {
                for (let i = 0; i < 25; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 40,
                        y: y + (Math.random() - 0.5) * 40,
                        vx: Math.cos(angle) * 80,
                        vy: Math.sin(angle) * 80,
                        life: 0.8,
                        maxLife: 0.8,
                        alpha: 1,
                        color: '#ff0000',
                        size: 4,
                        type: 'rage'
                    });
                }
            }
            
            createMeteorWarning(x, y) {
                // Create warning particles
                for (let i = 0; i < 40; i++) {
                    const angle = (i / 40) * Math.PI * 2;
                    const radius = 80;
                    this.particles.push({
                        x: x + Math.cos(angle) * radius,
                        y: y + Math.sin(angle) * radius,
                        vx: 0,
                        vy: 0,
                        life: 2,
                        maxLife: 2,
                        alpha: 1,
                        color: '#ff8800',
                        size: 2,
                        type: 'warning'
                    });
                }
            }
            
            createMeteorImpact(x, y) {
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * (100 + Math.random() * 100),
                        vy: Math.sin(angle) * (100 + Math.random() * 100),
                        life: 1.2,
                        maxLife: 1.2,
                        alpha: 1,
                        color: Math.random() > 0.5 ? '#ff4400' : '#ffaa00',
                        size: 4 + Math.random() * 4,
                        type: 'meteor'
                    });
                }
            }
            
            createSpinAttackEffect(x, y, radius) {
                for (let i = 0; i < 32; i++) {
                    const angle = (i / 32) * Math.PI * 2;
                    this.particles.push({
                        x: x + Math.cos(angle) * radius,
                        y: y + Math.sin(angle) * radius,
                        vx: Math.cos(angle) * 40,
                        vy: Math.sin(angle) * 40,
                        life: 0.6,
                        maxLife: 0.6,
                        alpha: 1,
                        color: '#ffffff',
                        size: 3,
                        type: 'spin'
                    });
                }
            }
            
            createShieldSlamEffect(x, y) {
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 120,
                        vy: Math.sin(angle) * 120,
                        life: 0.8,
                        maxLife: 0.8,
                        alpha: 1,
                        color: '#4444ff',
                        size: 4,
                        type: 'shield'
                    });
                }
            }
            
            // Networking
            sendNetworkUpdates() {
                const now = Date.now();
                if (now - this.lastNetworkUpdate < this.networkUpdateRate) return;
                
                this.lastNetworkUpdate = now;
                
                this.sendNetworkMessage({
                    type: 'player_update',
                    x: this.localPlayer.x,
                    y: this.localPlayer.y,
                    angle: this.localPlayer.angle,
                    health: this.localPlayer.health,
                    score: this.localPlayer.score,
                    isAlive: this.localPlayer.isAlive,
                    timestamp: now
                });
            }
            
            sendNetworkMessage(message) {
                if (this.connection && this.connection.open) {
                    this.connection.send(message);
                }
            }
            
            handleNetworkMessage(data, senderId) {
                switch (data.type) {
                    case 'player_join':
                        if (this.isHost) {
                            const newPlayer = {
                                id: senderId,
                                name: data.name,
                                character: data.character,
                                x: 200 + Math.random() * 200,
                                y: 200 + Math.random() * 200,
                                health: data.character ? data.character.health : 100,
                                score: 0,
                                isAlive: true,
                                angle: 0
                            };
                            
                            this.remotePlayers.set(senderId, newPlayer);
                            this.updateLobbyUI();
                            
                            // Send current lobby state to new player
                            this.connections.get(senderId).send({
                                type: 'lobby_joined',
                                players: Array.from(this.remotePlayers.values()),
                                host: {
                                    name: this.playerName,
                                    character: this.selectedCharacter
                                },
                                messages: this.chatMessages
                            });
                        }
                        break;
                        
                    case 'lobby_joined':
                        if (!this.isHost) {
                            // Load existing players
                            data.players.forEach(player => {
                                this.remotePlayers.set(player.id, player);
                            });
                            
                            // Load chat history
                            data.messages.forEach(msg => {
                                this.addChatMessage(msg);
                            });
                            
                            this.showLobby();
                        }
                        break;
                        
                    case 'chat':
                        this.addChatMessage(data.message);
                        break;
                        
                    case 'start_game':
                        this.gameMode = data.mode;
                        this.currentMap = MAPS[data.map] || MAPS.desert;
                        this.startGame();
                        break;
                        
                    case 'return_lobby':
                        this.showLobby();
                        break;
                        
                    case 'player_update':
                        const player = this.remotePlayers.get(senderId);
                        if (player) {
                            player.x = data.x;
                            player.y = data.y;
                            player.angle = data.angle;
                            player.health = data.health;
                            player.score = data.score;
                            player.isAlive = data.isAlive;
                        }
                        
                        // Calculate ping
                        if (data.timestamp) {
                            this.ping = Date.now() - data.timestamp;
                        }
                        break;
                        
                    case 'bullet':
                        const bullet = data.bullet;
                        bullet.owner = senderId;
                        this.bullets.push(bullet);
                        this.createMuzzleFlash(bullet.x, bullet.y, Math.atan2(bullet.vy, bullet.vx));
                        break;
                        
                    case 'special':
                        this.handleRemoteSpecial(data, senderId);
                        break;
                        
                    case 'hit':
                        const hitPlayer = this.remotePlayers.get(senderId);
                        if (hitPlayer) {
                            hitPlayer.score++;
                        }
                        break;
                        
                    case 'damage':
                        if (data.playerId) {
                            const damagedPlayer = this.remotePlayers.get(data.playerId);
                            if (damagedPlayer) {
                                damagedPlayer.health = data.health;
                                if (damagedPlayer.health <= 0) {
                                    this.playerDied(data.playerId);
                                }
                            }
                        }
                        break;
                        
                    case 'respawn':
                        const respawnPlayer = this.remotePlayers.get(senderId);
                        if (respawnPlayer) {
                            respawnPlayer.isAlive = true;
                            respawnPlayer.health = respawnPlayer.character.health;
                            respawnPlayer.x = data.x;
                            respawnPlayer.y = data.y;
                        }
                        break;
                }
            }
            
            handleRemoteSpecial(data, senderId) {
                switch (data.specialType) {
                    case 'dash':
                        this.createDashEffect(data.x, data.y);
                        break;
                    case 'range_shot':
                        this.createMuzzleFlash(data.x, data.y, data.angle);
                        break;
                    case 'shockwave':
                        this.createShockwaveEffect(data.x, data.y, 80);
                        
                        // Check if local player is in range
                        const dx = this.localPlayer.x - data.x;
                        const dy = this.localPlayer.y - data.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist < 80 && this.localPlayer.isAlive) {
                            this.localPlayer.health -= 40;
                            this.createBloodEffect(this.localPlayer.x, this.localPlayer.y);
                            
                            if (this.localPlayer.health <= 0) {
                                this.playerDied(this.localPlayer.id);
                            }
                        }
                        break;
                }
            }
            
            updateHUD() {
                document.getElementById('healthText').textContent = Math.max(0, this.localPlayer.health);
                const healthPercent = Math.max(0, (this.localPlayer.health / this.localPlayer.maxHealth) * 100);
                document.getElementById('healthBar').style.width = healthPercent + '%';
                document.getElementById('scoreText').textContent = this.localPlayer.score;
                
                // Show highest scoring opponent
                let topOpponent = { name: '--', score: 0 };
                this.remotePlayers.forEach(player => {
                    if (player.score > topOpponent.score) {
                        topOpponent = player;
                    }
                });
                
                document.getElementById('opponentScore').textContent = topOpponent.score;
                document.getElementById('opponentInfo').textContent = `Top: ${topOpponent.name}`;
                document.getElementById('pingText').textContent = this.ping;
            }
            
            endGame() {
                this.gameState = 'gameOver';
                this.hideAllMenus();
                document.getElementById('gameOverMenu').classList.remove('hidden');
                
                // Determine winner
                let winner = this.localPlayer;
                let isLocalWinner = true;
                
                this.remotePlayers.forEach(player => {
                    if (player.score > winner.score) {
                        winner = player;
                        isLocalWinner = false;
                    }
                });
                
                document.getElementById('gameOverTitle').textContent = 
                    isLocalWinner ? 'Victory!' : 'Defeat!';
                    
                // Show final scores
                const stats = document.getElementById('gameOverStats');
                let statsHTML = `<h3>Final Scores</h3>`;
                statsHTML += `<div>${this.playerName} (You): ${this.localPlayer.score}</div>`;
                
                this.remotePlayers.forEach(player => {
                    statsHTML += `<div>${player.name}: ${player.score}</div>`;
                });
                
                stats.innerHTML = statsHTML;
                
                this.broadcastMessage({
                    type: 'game_over',
                    winner: winner.name,
                    scores: {
                        [this.localPlayer.id]: this.localPlayer.score,
                        ...Array.from(this.remotePlayers.entries()).reduce((acc, [id, player]) => {
                            acc[id] = player.score;
                            return acc;
                        }, {})
                    }
                });
            }
            
            // Rendering
            render() {
                this.ctx.save();
                
                // Clear canvas
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.gameState === 'playing') {
                    // Apply camera transform
                    this.ctx.translate(-this.camera.x, -this.camera.y);
                    
                    // Render map background
                    this.renderMap();
                    
                    // Render obstacles
                    this.renderObstacles();
                    
                    // Render players
                    this.renderPlayers();
                    
                    // Render bullets with trails
                    this.renderBullets();
                    
                    // Render particles
                    this.renderParticles();
                    
                    // Render UI elements (reset transform)
                    this.ctx.restore();
                    this.renderMiniMap();
                } else {
                    this.ctx.restore();
                }
            }
            
            renderMap() {
                // Draw map bounds
                this.ctx.strokeStyle = '#444444';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(0, 0, this.currentMap.width, this.currentMap.height);
                
                // Grid pattern
                this.ctx.strokeStyle = '#2a2a2a';
                this.ctx.lineWidth = 1;
                const gridSize = 50;
                
                for (let x = 0; x < this.currentMap.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.currentMap.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.currentMap.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.currentMap.width, y);
                    this.ctx.stroke();
                }
            }
            
            renderObstacles() {
                this.obstacles.forEach(obstacle => {
                    if (obstacle.destroyed) return;
                    
                    let color;
                    switch (obstacle.type) {
                        case 'wall':
                            color = '#666666';
                            break;
                        case 'destructible':
                            color = '#884422';
                            break;
                        case 'cover':
                            color = '#445566';
                            break;
                        default:
                            color = '#444444';
                    }
                    
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.w, obstacle.h);
                    
                    // Add border
                    this.ctx.strokeStyle = '#888888';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(obstacle.x, obstacle.y, obstacle.w, obstacle.h);
                });
            }
            
            renderMiniMap() {
                const miniSize = 120;
                const miniX = this.canvas.width - miniSize - 10;
                const miniY = 10;
                const scale = miniSize / Math.max(this.currentMap.width, this.currentMap.height);
                
                // Mini map background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(miniX, miniY, miniSize, miniSize);
                
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(miniX, miniY, miniSize, miniSize);
                
                // Draw players on minimap
                this.ctx.fillStyle = '#00ff00';
                const localX = miniX + (this.localPlayer.x * scale);
                const localY = miniY + (this.localPlayer.y * scale);
                this.ctx.fillRect(localX - 2, localY - 2, 4, 4);
                
                this.ctx.fillStyle = '#ff0000';
                this.remotePlayers.forEach(player => {
                    if (player.isAlive) {
                        const x = miniX + (player.x * scale);
                        const y = miniY + (player.y * scale);
                        this.ctx.fillRect(x - 1, y - 1, 2, 2);
                    }
                });
            }
            
            renderPlayers() {
                // Local player
                if (this.localPlayer.isAlive) {
                    this.renderPlayer(this.localPlayer, '#00ff00', true);
                }
                
                // Remote players
                this.remotePlayers.forEach(player => {
                    if (player.isAlive) {
                        this.renderPlayer(player, '#ff0000', false);
                    }
                });
            }
            
            renderPlayer(player, color, isLocal) {
                const ctx = this.ctx;
                
                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.rotate(player.angle);
                
                // Character avatar based rendering
                if (player.character) {
                    // Character specific appearance
                    ctx.fillStyle = color;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, this.PLAYER_SIZE, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Character avatar in center
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(player.character.avatar, 0, 5);
                } else {
                    // Default appearance
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.PLAYER_SIZE, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Direction indicator
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.PLAYER_SIZE - 5, -2, 12, 4);
                
                ctx.restore();
                
                // Player name and character name
                ctx.fillStyle = isLocal ? '#00ff00' : '#ffffff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(player.name, player.x, player.y - this.PLAYER_SIZE - 25);
                
                if (player.character) {
                    ctx.fillStyle = '#aaaaaa';
                    ctx.font = '10px Arial';
                    ctx.fillText(player.character.name, player.x, player.y - this.PLAYER_SIZE - 13);
                }
                
                // Health bar
                const barWidth = 40;
                const barHeight = 6;
                const maxHealth = player.character ? player.character.health : 100;
                const healthPercent = Math.max(0, player.health / maxHealth);
                
                ctx.fillStyle = '#333333';
                ctx.fillRect(player.x - barWidth/2, player.y - this.PLAYER_SIZE - 6, barWidth, barHeight);
                
                ctx.fillStyle = healthPercent > 0.6 ? '#22c55e' : healthPercent > 0.3 ? '#fbbf24' : '#ef4444';
                ctx.fillRect(player.x - barWidth/2, player.y - this.PLAYER_SIZE - 6, barWidth * healthPercent, barHeight);
            }
            
            renderBullets() {
                this.bullets.forEach(bullet => {
                    // Render bullet trail
                    if (bullet.trail && bullet.trail.length > 1) {
                        this.ctx.strokeStyle = bullet.special ? '#ffaa00' : 'rgba(255, 255, 255, 0.4)';
                        this.ctx.lineWidth = bullet.special ? 4 : 2;
                        this.ctx.lineCap = 'round';
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(bullet.trail[0].x, bullet.trail[0].y);
                        
                        for (let i = 1; i < bullet.trail.length; i++) {
                            this.ctx.lineTo(bullet.trail[i].x, bullet.trail[i].y);
                        }
                        
                        this.ctx.stroke();
                    }
                    
                    // Render bullet with glow effect
                    this.ctx.save();
                    
                    // Outer glow
                    this.ctx.shadowColor = bullet.special ? '#ffaa00' : '#ffffff';
                    this.ctx.shadowBlur = 10;
                    
                    this.ctx.fillStyle = bullet.special ? '#ffaa00' : '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bullet.special ? 5 : 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                });
            }
            
            renderParticles() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.alpha;
                    
                    // Add glow effect for certain particle types
                    if (particle.type === 'muzzle' || particle.type === 'explosion') {
                        this.ctx.shadowColor = particle.color;
                        this.ctx.shadowBlur = 15;
                    }
                    
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                });
            }
            
            // Enhanced mobile controls
            setupMobileControls() {
                const container = document.getElementById('joystickContainer');
                const knob = document.getElementById('joystickKnob');
                
                // Add special ability button
                const controlsRight = document.createElement('div');
                controlsRight.className = 'controls-right';
                controlsRight.innerHTML = `
                    <div class="special-btn" id="specialBtn">‚ú®<br>SPEC</div>
                `;
                
                const mobileControls = document.querySelector('.mobile-controls');
                mobileControls.appendChild(controlsRight);
                
                // Special button
                document.getElementById('specialBtn').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.gameState === 'playing') {
                        this.useSpecial();
                    }
                });
                
                const handleStart = (e) => {
                    e.preventDefault();
                    const rect = container.getBoundingClientRect();
                    this.joystick.centerX = rect.left + rect.width / 2;
                    this.joystick.centerY = rect.top + rect.height / 2;
                    this.joystick.active = true;
                    
                    const touch = e.touches ? e.touches[0] : e;
                    this.updateJoystick(touch.clientX, touch.clientY);
                };
                
                const handleMove = (e) => {
                    if (!this.joystick.active) return;
                    e.preventDefault();
                    const touch = e.touches ? e.touches[0] : e;
                    this.updateJoystick(touch.clientX, touch.clientY);
                };
                
                const handleEnd = (e) => {
                    e.preventDefault();
                    this.joystick.active = false;
                    this.joystick.x = 0;
                    this.joystick.y = 0;
                    knob.style.transform = 'translate(-50%, -50%)';
                };
                
                container.addEventListener('touchstart', handleStart);
                container.addEventListener('touchmove', handleMove);
                container.addEventListener('touchend', handleEnd);
                container.addEventListener('mousedown', handleStart);
                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleEnd);
            }

            // Main game loop
            gameLoop() {
                const now = Date.now();
                const deltaTime = Math.min((now - (this.lastTime || now)) / 1000, 0.016); // Cap at 60fps
                this.lastTime = now;
                
                this.updateGame(deltaTime);
                this.updateBots(deltaTime);
                this.updateZombies(deltaTime);
                this.updateGameMode(deltaTime);
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Safe DOM initialization
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                console.log('DOM loaded, initializing game...');
                
                // Ensure Firebase is ready
                if (!window.firebase || !window.firebase.auth) {
                    throw new Error('Firebase not properly loaded');
                }
                
                // Initialize game
                game = new BattleArena2D();
                console.log('Game instance created');
                
                // Initialize Firebase connection
                await game.initFirebase();
                console.log('Firebase initialized');
                
                // Setup canvas events
                const canvas = document.getElementById('gameCanvas');
                if (canvas) {
                    canvas.addEventListener('contextmenu', e => e.preventDefault());
                } else {
                    console.error('Canvas element not found!');
                }
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    if (game && game.gameState === 'playing') {
                        const maxWidth = Math.min(game.currentMap.width, window.innerWidth - 40);
                        const maxHeight = Math.min(game.currentMap.height, window.innerHeight - 40);
                        game.canvas.width = maxWidth;
                        game.canvas.height = maxHeight;
                    }
                });
                
                // Make game available globally for button onclick handlers
                window.game = game;
                
            } catch (error) {
                console.error('Critical initialization error:', error);
                
                // Show error in login screen
                const container = document.querySelector('.container');
                if (container) {
                    container.innerHTML = `
                        <div class="menu">
                            <h1>‚öîÔ∏è Battle Arena 2D</h1>
                            <div class="status status-error">
                                <strong>Erro Cr√≠tico:</strong><br>
                                ${error.message}<br><br>
                                Verifique sua conex√£o e tente recarregar a p√°gina.
                            </div>
                            <button class="btn" onclick="window.location.reload()">üîÑ Recarregar P√°gina</button>
                        </div>
                    `;
                }
            }
        });
    </script>
</body>
</html>